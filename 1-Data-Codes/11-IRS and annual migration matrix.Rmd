---
title: "IRS data and annual migration matrix"
author: "Yuanhang(Leo) Yu"
date: "2023-05-26"
output:
  html_document:
    toc: yes
    df_print: paged
  # pdf_document:
    # number_sections: yes
  # html_notebook:
    # toc: yes
    # df_print: paged
    # number_sections: yes
header-includes:
- \usepackage{amsmath}
- \usepackage{amssymb}
- \usepackage{pifont}
- \usepackage{mathpazo}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
remove(list = ls())  
```

```{r message=FALSE, warning=FALSE, cache=FALSE, include=FALSE, results='hide'}
# Define function
`%notin%` <- Negate(`%in%`)
# libraries
options( scipen=100, digits = 15, stringsAsFactors=FALSE ); # no scientific notation, up to 15 digits 
# vector of libraries to be used
libs <- c( 'dplyr', 'tidyr', 'haven', 'stringr', 'nleqslv', 'gdata', 'formattable', 'ggplot2', 'viridis', 'RColorBrewer', 'reshape2', 'foreign', 'readxl', 'writexl', 'rjson', 'read_excel', 'Matrix', 'geodist', 'readr', 'data.table', 'stringr', 'haven');
# Install libraries in case they are not installed
for( i in seq_along(libs)){ 
    if( !(libs[i] %in% installed.packages()) ) install.packages( libs[i] ) 
};
# Loading libraries
lapply( libs, require, character.only=TRUE );
```

```{r additional data}
# region: US states and other countries
regions <- read.csv("0-Raw_Data/regions.csv")  
c_names <- regions %>% filter(status == "country")
c_names <- c_names$region

s_names <- regions %>% filter(status == "state") 
s_names <- s_names$region

# sector reclassification table (NAICS to final)
sectors_naics_final <- read.csv(paste("0-Raw_Data/sectors.csv", sep=""), header = TRUE, sep = ",", dec = ".")
sectors_naics_final <- sectors_naics_final %>% 
  select(final_sector, naics) %>%
  mutate(naics = as.character(naics)) %>%
  distinct(final_sector, naics)     #create the mapping table from NAICS to final at sector level

# sectors (CENSUS 1990 to final)
sectors_census1990_final <- read.csv(paste("0-Raw_Data/sectors_census_1990.csv", sep=""), header = TRUE, sep = ",", dec = ".")
sectors_census1990_final <- sectors_census1990_final %>%
  filter(is.na(final_sector) == FALSE) %>%
  mutate(census_1990 = as.character(census_1990)) %>%
  select(census_1990, final_sector)

# sectors (CENSUS 2003 to naics)
sectors_census2003_naics <- read.csv(paste("0-Raw_Data/sectors_census_2003.csv", sep=""), header = TRUE, sep = ",", dec = ".")
sectors_census2003_naics <- sectors_census2003_naics %>%
  mutate(naics = as.character(naics)) %>%
  distinct(census_2003, .keep_all = TRUE)

# sectors (CENSUS 2003 to final)
sectors_census2003_final <- sectors_census2003_naics %>%
  left_join(sectors_naics_final, by=c('naics'='naics')) %>% #NAICS to final sector
  filter(is.na(final_sector) == FALSE) %>%
  mutate(census_2003 = as.character(census_2003)) %>%
  select(census_2003, final_sector)

# state codes
states_fips <- read_excel("0-Raw_Data/Fips/states_fips_num.xlsx", range = "A1:D53")
states_fips_mod_ACS <- states_fips %>% 
  select(st_num, st_name) %>%
  mutate(st_num = ifelse(st_num > 8, st_num + 1, st_num)) %>%
  distinct(st_name, .keep_all = TRUE) %>%
  dplyr::rename(st_name1 = st_name)  #state code that is consistent with used in ACS
states_fips <- states_fips %>% select(st_fips, st_num, st_name)
```

## IRS data

This section processes the county-level IRS migration data.

```{r include=FALSE}
 
######## This part cleans the county-by-county IRS data ########## 

irs_temp  <- read_dta("0-Raw_Data/IRS/1999to2000CountyMigration/1999to2000flow.dta")

state_name  <- c("Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut", "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "NewHampshire", "NewJersey", "NewMexico", "NewYork", "NorthCarolina", "NorthDakota", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "RhodeIsland", "SouthCarolina", "SouthDakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "WestVirginia", "Wisconsin", "Wyoming")

all_combo <- c()
for (state in state_name) {
temp <- data.frame(state_name) #list of regions
temp <- temp %>%
  dplyr::rename(state_ori = state_name) %>%
  mutate(state_dest = state)  #create destination state and sector
all_combo <- bind_rows(all_combo, temp) #add all together, therefore all combination 
}

irs  <- all_combo %>% 
  left_join(irs_temp, by = c('state_dest' = 'state_dest', 'state_ori' = 'state_ori'))  %>% 
  mutate(year = 1999)  %>% 
  mutate(exemption = ifelse(is.na(exemption), 0, exemption))

write.table(irs, file = paste("1-Intermediate_Processed_Data/irs.csv", sep=""), sep = ",", row.names = FALSE) 

```

## Proportionality assumption with IRS data: final case IRS version 4 (case 2)

### Migration matrix with IRS 
Within the State
$$
L^{n j, n k}=L_{I R S}^{n, n} \times \frac{L_{C P S}^{n j, n k}}{\sum_q \sum_h L_{C P S}^{n h, n q}} \quad \forall n \in U S A, \forall j, k
$$
Between States
$$
L^{n j, i k}=\frac{L_{A C S}^{n \#, i k}}{\sum_q L_{A C S}^{n \#, i q}} \times L_{I R S}^{n, i} \times \frac{L_{C P S}^{i j, i k}}{\sum_h L_{C P S}^{i h, i k}} \quad (n \neq i)
$$
```{r}
# loading intermediate CPS
cps <- read.csv(paste("1-Intermediate_Processed_Data/cps_2.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# within states proportionality
temp_within  <- cps %>%           # create the cps share for within state expression
  filter(state_ori == state_dest & year == 1999)  %>% 
  group_by(year, state_dest, state_ori)  %>% 
  mutate(n_cps_two_states_tot = sum(n_cps))  %>% 
  ungroup()  %>% 
  mutate(cps_share_wti = n_cps/n_cps_two_states_tot) %>% 
  select(year, state_ori, state_dest, sector_ori, sector_dest, cps_share_wti)

# between states proportionality
temp_between_cps  <- cps  %>%    # create the cps share for between state expression
  filter(state_ori == state_dest & year == 1999)  %>% 
  group_by(year, state_dest, state_ori, sector_dest)  %>% 
  mutate(n_cps_same_sector_dest = sum(n_cps))  %>% 
  ungroup()  %>% 
  mutate(cps_share_btw = n_cps/n_cps_same_sector_dest)  %>% 
  select(year, state_ori, state_dest, sector_ori, sector_dest, cps_share_btw)

acs <- read.csv(paste("1-Intermediate_Processed_Data/acs.csv", sep=""), header = TRUE, sep = ",", dec = ".")

temp_between_acs  <-  acs  %>%  # create the acs share for between state expression
  filter(year == 1999)  %>% 
  group_by(year, state_dest, state_ori)  %>% 
  mutate(n_acs_two_tot = sum(n_acs))  %>% 
  ungroup()  %>% 
  mutate(acs_share = n_acs/n_acs_two_tot)  %>% 
  mutate(acs_share = ifelse(is.na(acs_share), 0, acs_share))  %>% 
  select(year, state_ori, state_dest, sector_dest, acs_share)

irs <-  read.csv(paste("1-Intermediate_Processed_Data/irs.csv", sep=""), header = TRUE, sep = ",", dec = ".")

mobility  <- cps  %>%   # adjusted migration flows
  filter(year == 1999)  %>% 
  left_join(irs, by=c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori')) %>%
  left_join(temp_within, by = c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest', 'sector_ori' = 'sector_ori'))  %>% 
  left_join(temp_between_acs, by = c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest'))  %>% 
  left_join(temp_between_cps, by = c('year' = 'year', 'state_dest' = 'state_dest', 'sector_dest' = 'sector_dest', 'sector_ori' = 'sector_ori'))  %>% 
  rename(state_ori = state_ori.x)  %>% 
  mutate(n_cps_adj = exemption * acs_share * cps_share_btw)  %>% 
  mutate(n_cps_adj = ifelse(state_ori == state_dest, exemption*cps_share_wti, n_cps_adj))  %>% 
  select(-state_ori.y)

# mu_1999 prime for L_1999
# the second part of this calculation is in the next step since there is an additional proportionality that has to be implemented in L_2000 so that it is consistent with WIOD
mu_1999_prime <- mobility %>%
  group_by(year, state_dest, sector_dest) %>% 
  mutate(tot_n = sum(n_cps_adj)) %>% # total inflows to destination state-sector
  ungroup() %>%
  mutate(rel = n_cps_adj/tot_n) %>%  #(inflow share of destination state-sector across original state-sector) rel: share of people from original state-sector pairs to the same destination state-sector
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel)

# mu_1999 prime for L_1999
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars = c("state"), variable.name = "sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector)))
mu_1999_prime <- mu_1999_prime %>%
  left_join(L_2000, by=c('state_dest' = 'state', 'sector_dest' = 'sector')) %>% 
  mutate(level_employ = rel*employ) %>%   # generate the 1999 migration flows based on the 2000 distribution and 1999 migration share
  select(-rel, -employ)
write.table(mu_1999_prime, file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case2.csv", sep=""), sep = ",", row.names = FALSE)

# Computing L_1999 using mobility matrices and L_2000
L_1999 <- mu_1999_prime %>%
  group_by(state_ori, sector_ori) %>%
  mutate(employ = sum(level_employ)) %>%  # 1999 labour distribution
  ungroup() %>%
  distinct(state_ori, sector_ori, .keep_all = TRUE) %>%
  dplyr::rename(state = state_ori, sector = sector_ori) %>%
  select(state, sector, employ) %>%
  arrange(state, sector)
temp_L_1999 <- L_1999
L_1999 <- spread(L_1999, sector, employ, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)
write.table(L_1999, file = paste("1-Intermediate_Processed_Data/L_1999_case2.csv", sep=""), sep = ",", row.names = FALSE)

# Recalculating mu_1999 and checking flow 1999-2000
mu_1999 <- mu_1999_prime %>% 
  dplyr::rename(n_cps_adj_ = level_employ) %>%
  group_by(year, state_ori, sector_ori) %>% 
  mutate(tot_n_cps_accros_dest = sum(n_cps_adj_)) %>% 
  ungroup() %>%
  mutate(rel = n_cps_adj_/tot_n_cps_accros_dest) %>% # migration (out) share in 1999
  distinct(state_dest, state_ori, sector_dest, sector_ori, .keep_all = TRUE) %>% 
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel) %>%
  arrange(year, state_ori, sector_ori, state_dest, sector_dest)
write_xlsx(mu_1999, path = paste("1-Intermediate_Processed_Data/mu_1999_case2_long_format.xlsx", sep=""))
mu_1999 <- mu_1999 %>%
  mutate(sector_dest = recode(as.character(sector_dest), '0' ="00", '1' ="01", '2' ="02", '3' ="03", '4' ="04", '5' ="05", '6' ="06", '7' ="07", '8' ="08", '9' ="09" )) %>%
  mutate(state_dest_sector_dest = paste(state_dest, sector_dest, sep="_")) %>%
  select(-state_dest, -sector_dest)
mu_1999 <- spread(mu_1999, state_dest_sector_dest, rel, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# check sum(prob)==1
epsilon <- 0.01
check <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
if(sum(abs(as.matrix(rowSums(check)) - matrix(1, dim(check)[1], 1))) > epsilon) 
  stop("mobility shares do not add to 1")
write_xlsx(mu_1999, path = paste("2-Final_Data/mu_1999_case2.xlsx", sep=""))

# check L_1999 and mu_1999 gives L_2000
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars=c("state"), variable.name="sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector))) %>%
  arrange(state, sector)
L_2000 <- as.matrix(L_2000$employ)
L_1999 <- as.matrix(temp_L_1999$employ)
mu_1999 <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
mu_1999 <- as.matrix(mu_1999)
if(sum(L_2000 - (t(mu_1999)%*%L_1999)) > epsilon) 
  stop(paste("L_1999 and mu_1999 do NOT give L_2000"))

```

## Comparison of different migration matrices
I compare three different matrices based on different method of proportionality

  - Case 0: Original matrix with CPS and ACS without modification on the diagonal
  
$$
L^{nj,ik}=\sum_{q}L_{ACS}^{n?,iq}\times\frac{L_{CPS}^{ij,ik}}{\sum_{q}\sum_{h}L_{CPS}^{ih,iq}}\quad\forall n,i\in US;\,\forall j,k
$$

  - Case 1: Original matrix with CPS and ACS with modified diagonal proportionality (see 2.1 on the migration_math.lyx)
  
$$
L^{nj,ik}=\sum_{q}L_{ACS}^{n?,iq}\times\frac{L_{CPS}^{ij,ik}}{\sum_{q}\sum_{h}L_{CPS}^{ih,iq}}\quad\forall n,i\in US;\,\forall j,k
$$
  - Case 2: Matrix with IRS version 4 (see section New: June 11th) 
  
$$
L^{nj,nk}=L_{IRS}^{n,n}\times\frac{L_{CPS}^{nj,nk}}{\sum_{q}\sum_{h}L_{CPS}^{nh,nq}} \quad \forall n\in USA,\forall j,k  \\
L^{nj,ik}=\frac{L_{CPS}^{ij,ik}}{\sum_{h}L_{CPS}^{ih,ik}}\times L_{IRS}^{n,i}\times\frac{L_{ACS}^{n\#,ik}}{\sum_{q}L_{ACS}^{n\#,iq}}
$$

### Add code produced case 0 and case 1 for simplicity

```{r}
#### Case 0 ####
# loading intermediate CPS
cps <- read.csv(paste("1-Intermediate_Processed_Data/cps_2_case0.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# loading intermediate ACS
acs <- read.csv(paste("1-Intermediate_Processed_Data/acs.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# Mobility matrices
# disaggregating ACS data using CPS sector_ori info and computation of mobility share
# origin in rows and destination in columns
# row shares sum to 1
acs <- acs %>%
  group_by(year, state_ori, state_dest) %>%
  mutate(n_acs = sum(n_acs)) %>% # n_acs: for (state_ori, state_dest) pair, n_acs is the total migration summed over all destination sectors
  ungroup() %>%
  distinct(year, state_ori, state_dest, .keep_all = TRUE) %>%
  select(-sector_dest)  # total migration from state i to state j for each (i,j) combination

# adjusting x's to y's: cps migration pair share times total migration from acs
mobility <- cps %>%
  left_join(acs, by=c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori')) %>%
  group_by(year, state_dest, state_ori) %>% 
  mutate(tot_n_cps_accros_sec = sum(n_cps)) %>% # totol within destination state migration (sum over all sector movements)
  ungroup() %>%
  mutate(n_cps_adj = n_cps/tot_n_cps_accros_sec) %>% # migration share across sectors within state (based on destination state)
  mutate(n_cps_adj = ifelse(is.na(n_cps_adj) == TRUE, 0, n_cps_adj)) %>%
  mutate(n_cps_adj = n_cps_adj*n_acs) %>% # use cps within-state across sector migration share times acs total migration across states
  select(-tot_n_cps_accros_sec, -n_cps, -n_acs) 

# mu_1999 prime for L_1999
# the second part of this calculation is in the next step since there is an additional proportionality that has to be implemented in L_2000 so that it is consistent with WIOD
mu_1999_prime <- mobility %>%
  filter(year == 1999) %>%
  group_by(year, state_dest, sector_dest) %>% 
  mutate(tot_n = sum(n_cps_adj)) %>% # total inflows to destination state-sector
  ungroup() %>%
  mutate(rel = n_cps_adj/tot_n) %>%  # (inflow share of destination state-sector across original state-sector)rel: share of people from original state-sector pairs to the same destination state-sector
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel)

# mu_1999 prime for L_1999
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars = c("state"), variable.name = "sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector)))
mu_1999_prime <- mu_1999_prime %>%
  left_join(L_2000, by=c('state_dest' = 'state', 'sector_dest' = 'sector')) %>% 
  mutate(level_employ = rel*employ) %>%   # generate the 1999 migration flows based on the 2000 distribution and 1999 migration share
  select(-rel, -employ)
write.table(mu_1999_prime, file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case0.csv", sep=""), sep = ",", row.names = FALSE)

# Computing L_1999 using mobility matrices and L_2000
L_1999 <- mu_1999_prime %>%
  group_by(state_ori, sector_ori) %>%
  mutate(employ = sum(level_employ)) %>%  # 1999 labour distribution
  ungroup() %>%
  distinct(state_ori, sector_ori, .keep_all = TRUE) %>%
  dplyr::rename(state = state_ori, sector = sector_ori) %>%
  select(state, sector, employ) %>%
  arrange(state, sector)
temp_L_1999 <- L_1999
L_1999 <- spread(L_1999, sector, employ, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# Recalculating mu_1999 and checking flow 1999-2000
mu_1999 <- mu_1999_prime %>% 
  dplyr::rename(n_cps_adj_ = level_employ) %>%
  group_by(year, state_ori, sector_ori) %>% 
  mutate(tot_n_cps_accros_dest = sum(n_cps_adj_)) %>% 
  ungroup() %>%
  mutate(rel = n_cps_adj_/tot_n_cps_accros_dest) %>% # migration (out) share in 1999
  distinct(state_dest, state_ori, sector_dest, sector_ori, .keep_all = TRUE) %>% 
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel) %>%
  arrange(year, state_ori, sector_ori, state_dest, sector_dest)
write_xlsx(mu_1999, path = paste("1-Intermediate_Processed_Data/mu_1999_case0_long_format.xlsx", sep=""))
mu_1999 <- mu_1999 %>%
  mutate(sector_dest = recode(as.character(sector_dest), '0' ="00", '1' ="01", '2' ="02", '3' ="03", '4' ="04", '5' ="05", '6' ="06", '7' ="07", '8' ="08", '9' ="09" )) %>%
  mutate(state_dest_sector_dest = paste(state_dest, sector_dest, sep="_")) %>%
  select(-state_dest, -sector_dest)
mu_1999 <- spread(mu_1999, state_dest_sector_dest, rel, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# check sum(prob)==1
epsilon <- 0.01
check <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
if(sum(abs(as.matrix(rowSums(check)) - matrix(1, dim(check)[1], 1))) > epsilon) 
  stop("mobility shares do not add to 1")
write_xlsx(mu_1999, path = paste("2-Final_Data/mu_1999_case0.xlsx", sep=""))

# check L_1999 and mu_1999 gives L_2000
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars=c("state"), variable.name="sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector))) %>%
  arrange(state, sector)
L_2000 <- as.matrix(L_2000$employ)
L_1999 <- as.matrix(temp_L_1999$employ)
mu_1999 <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
mu_1999 <- as.matrix(mu_1999)
if(sum(L_2000 - (t(mu_1999)%*%L_1999)) > epsilon) 
  stop(paste("L_1999 and mu_1999 do NOT give L_2000"))


#### Case 1 ####
# loading intermediate CPS
cps <- read.csv(paste("1-Intermediate_Processed_Data/cps_2.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# loading intermediate ACS
acs <- read.csv(paste("1-Intermediate_Processed_Data/acs.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# Mobility matrices
# disaggregating ACS data using CPS sector_ori info and computation of mobility share
# origin in rows and destination in columns
# row shares sum to 1
acs <- acs %>%
  group_by(year, state_ori, state_dest) %>%
  mutate(n_acs = sum(n_acs)) %>% # n_acs: for (state_ori, state_dest) pair, n_acs is the total migration summed over all destination sectors
  ungroup() %>%
  distinct(year, state_ori, state_dest, .keep_all = TRUE) %>%
  select(-sector_dest)  # total migration from state i to state j for each (i,j) combination

# adjusting x's to y's: cps migration pair share times total migration from acs
mobility <- cps %>%
  left_join(acs, by=c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori')) %>%
  group_by(year, state_dest, state_ori) %>% 
  mutate(tot_n_cps_accros_sec = sum(n_cps)) %>% # totol within destination state migration (sum over all sector movements)
  ungroup() %>%
  mutate(n_cps_adj = n_cps/tot_n_cps_accros_sec) %>% # migration share across sectors within state (based on destination state)
  mutate(n_cps_adj = ifelse(is.na(n_cps_adj) == TRUE, 0, n_cps_adj)) %>%
  mutate(n_cps_adj = n_cps_adj*n_acs) %>% # use cps within-state across sector migration share times acs total migration across states
  select(-tot_n_cps_accros_sec, -n_cps, -n_acs) 

# mu_1999 prime for L_1999
# the second part of this calculation is in the next step since there is an additional proportionality that has to be implemented in L_2000 so that it is consistent with WIOD
mu_1999_prime <- mobility %>%
  filter(year == 1999) %>%
  group_by(year, state_dest, sector_dest) %>% 
  mutate(tot_n = sum(n_cps_adj)) %>% # total inflows to destination state-sector
  ungroup() %>%
  mutate(rel = n_cps_adj/tot_n) %>%  # (inflow share of destination state-sector across original state-sector)rel: share of people from original state-sector pairs to the same destination state-sector
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel)

# mu_1999 prime for L_1999
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars = c("state"), variable.name = "sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector)))
mu_1999_prime <- mu_1999_prime %>%
  left_join(L_2000, by=c('state_dest' = 'state', 'sector_dest' = 'sector')) %>% 
  mutate(level_employ = rel*employ) %>%   # generate the 1999 migration flows based on the 2000 distribution and 1999 migration share
  select(-rel, -employ)
write.table(mu_1999_prime, file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case1.csv", sep=""), sep = ",", row.names = FALSE)

# Computing L_1999 using mobility matrices and L_2000
L_1999 <- mu_1999_prime %>%
  group_by(state_ori, sector_ori) %>%
  mutate(employ = sum(level_employ)) %>%  # 1999 labour distribution
  ungroup() %>%
  distinct(state_ori, sector_ori, .keep_all = TRUE) %>%
  dplyr::rename(state = state_ori, sector = sector_ori) %>%
  select(state, sector, employ) %>%
  arrange(state, sector)
temp_L_1999 <- L_1999
L_1999 <- spread(L_1999, sector, employ, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)
# write.table(L_1999, file = paste("1-Intermediate_Processed_Data/L_1999.csv", sep=""), sep = ",", row.names = FALSE)

# Recalculating mu_1999 and checking flow 1999-2000
mu_1999 <- mu_1999_prime %>% 
  dplyr::rename(n_cps_adj_ = level_employ) %>%
  group_by(year, state_ori, sector_ori) %>% 
  mutate(tot_n_cps_accros_dest = sum(n_cps_adj_)) %>% 
  ungroup() %>%
  mutate(rel = n_cps_adj_/tot_n_cps_accros_dest) %>% # migration (out) share in 1999
  distinct(state_dest, state_ori, sector_dest, sector_ori, .keep_all = TRUE) %>% 
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel) %>%
  arrange(year, state_ori, sector_ori, state_dest, sector_dest)
write_xlsx(mu_1999, path = paste("1-Intermediate_Processed_Data/mu_1999_case1_long_format.xlsx", sep=""))
mu_1999 <- mu_1999 %>%
  mutate(sector_dest = recode(as.character(sector_dest), '0' ="00", '1' ="01", '2' ="02", '3' ="03", '4' ="04", '5' ="05", '6' ="06", '7' ="07", '8' ="08", '9' ="09" )) %>%
  mutate(state_dest_sector_dest = paste(state_dest, sector_dest, sep="_")) %>%
  select(-state_dest, -sector_dest)
mu_1999 <- spread(mu_1999, state_dest_sector_dest, rel, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# check sum(prob)==1
epsilon <- 0.01
check <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
if(sum(abs(as.matrix(rowSums(check)) - matrix(1, dim(check)[1], 1))) > epsilon) 
  stop("mobility shares do not add to 1")
write_xlsx(mu_1999, path = paste("2-Final_Data/mu_1999_case1.xlsx", sep=""))

# check L_1999 and mu_1999 gives L_2000
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars=c("state"), variable.name="sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector))) %>%
  arrange(state, sector)
L_2000 <- as.matrix(L_2000$employ)
L_1999 <- as.matrix(temp_L_1999$employ)
mu_1999 <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
mu_1999 <- as.matrix(mu_1999)
if(sum(L_2000 - (t(mu_1999)%*%L_1999)) > epsilon) 
  stop(paste("L_1999 and mu_1999 do NOT give L_2000"))

```
For each state
1. Average of the diagonals: within state within sector; Max min median of the diagonals 

2. Probability stay-in state (within state migration): the probability that they stay in the same state (any sector)

3. Probability stay-in sector (within same sector migration): the probability that they stay in the same sector (regardless maybe state change)

4. Transition probability

For all state
Histogram of all diagonals across all states

To benchmark the transition probability from annual migration matrix to the literature:
The numbers are consistent with the estimates by Molloy, Smith, and Wozniak (2011) for annual interstate moves and Kambourov and Manovskii (2008) for intersectoral mobility.


```{r transition probablity at state level}
# average for migration share within same state within same sector
mu_1999_0  <- read_xlsx(path = paste("1-Intermediate_Processed_Data/mu_1999_case0_long_format.xlsx", sep=""))
mu_1999_1  <- read_xlsx(path = paste("1-Intermediate_Processed_Data/mu_1999_case1_long_format.xlsx", sep=""))
mu_1999_2  <- read_xlsx(path = paste("1-Intermediate_Processed_Data/mu_1999_case2_long_format.xlsx", sep=""))

suffixes <- c("0", "1", "2")   # Define a vector of suffixes for the data frames
average_diag_list <- list()    # Create an empty list to store the results
columns_to_suffix <- c("mean_diag", "max_diag", "min_diag", "p25_diag", "p50_diag", "p75_diag")

for (suffix in suffixes) {     # Loop over the suffixes and process the data frames
  current_df <- get(paste0("mu_1999_", suffix))
  
  current_average_diag <- current_df %>%
    filter(state_ori == state_dest & sector_ori == sector_dest) %>%
    group_by(state_ori) %>%
    summarise(
      mean_diag = mean(rel),
      max_diag = max(rel),
      min_diag = min(rel),
      p25_diag = quantile(rel, 0.25),
      p50_diag = quantile(rel, 0.5),
      p75_diag = quantile(rel, 0.75)
    ) %>%
    ungroup()

  colnames(current_average_diag)[colnames(current_average_diag) %in% columns_to_suffix] <-
    paste0(colnames(current_average_diag)[colnames(current_average_diag) %in% columns_to_suffix], "_", suffix)
  
  average_diag_list[[suffix]] <- current_average_diag
}

average_diag <- Reduce(function(x, y) left_join(x, y, by = "state_ori"), average_diag_list)  # Merge the results into a single data frame

average_diag  <- average_diag  %>% 
  select(state_ori, mean_diag_0, mean_diag_1, mean_diag_2, max_diag_0, max_diag_1, max_diag_2, min_diag_0, min_diag_1, min_diag_2, p25_diag_0, p25_diag_1, p25_diag_2, p50_diag_0, p50_diag_1, p50_diag_2, p75_diag_0, p75_diag_1, p75_diag_2)

write_xlsx(average_diag, "1-Intermediate_Processed_Data/average_diag.xlsx")

# Probability stay-in same state (at original state level)
migration_1999_0  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case0.csv", sep=""), header = TRUE, sep = ",", dec = ".")
migration_1999_1  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case1.csv", sep=""), header = TRUE, sep = ",", dec = ".")
migration_1999_2  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case2.csv", sep=""), header = TRUE, sep = ",", dec = ".")

suffixes <- c("0", "1", "2")   # Define a vector of suffixes for the data frames
prob_same_state_list <- list()   # Create an empty list to store the results
columns_to_suffix <- c("stay_in_state_share")

for (suffix in suffixes) {    # Loop over the suffixes and process the data frames
  current_df <- get(paste0("migration_1999_", suffix))
  
  current_same_state <- current_df %>%
    group_by(year, state_ori)  %>% 
    mutate(l_1999 = sum(level_employ))  %>% 
    mutate(stay_in_num = sum(level_employ[state_ori == state_dest]))  %>% 
    ungroup()  %>% 
    mutate(stay_in_state_share = stay_in_num/l_1999)  %>% 
    select(state_ori, stay_in_state_share)  %>% 
    distinct(state_ori, stay_in_state_share, .keep_all = TRUE)

  colnames(current_same_state)[colnames(current_same_state) %in% columns_to_suffix] <-
    paste0(colnames(current_same_state)[colnames(current_same_state) %in% columns_to_suffix], "_", suffix)
  
  prob_same_state_list[[suffix]] <- current_same_state
}

prob_same_state <- Reduce(function(x, y) left_join(x, y, by = "state_ori"), prob_same_state_list)  # Merge the results into a single data frame
write_xlsx(prob_same_state, "1-Intermediate_Processed_Data/prob_same_state(at state level).xlsx")

# Probability stay-in same sector (at original state level)
suffixes <- c("0", "1", "2")   # Define a vector of suffixes for the data frames
prob_same_sector_list <- list()   # Create an empty list to store the results
columns_to_suffix <- c("stay_in_sector_share")

for (suffix in suffixes) {     # Loop over the suffixes and process the data frames
  current_df <- get(paste0("migration_1999_", suffix))
  
  current_same_sector <- current_df %>%
    group_by(year, state_ori)  %>% 
    mutate(l_1999 = sum(level_employ))  %>% 
    mutate(stay_in_num = sum(level_employ[sector_ori == sector_dest]))  %>% 
    ungroup()  %>% 
    mutate(stay_in_sector_share = stay_in_num/l_1999)  %>% 
    select(state_ori, stay_in_sector_share)  %>% 
    distinct(state_ori, stay_in_sector_share, .keep_all = TRUE)

  colnames(current_same_sector)[colnames(current_same_sector) %in% columns_to_suffix] <-
    paste0(colnames(current_same_sector)[colnames(current_same_sector) %in% columns_to_suffix], "_", suffix)
  
  prob_same_sector_list[[suffix]] <- current_same_sector
}

prob_same_sector <- Reduce(function(x, y) left_join(x, y, by = "state_ori"), prob_same_sector_list)  # Merge the results into a single data frame
write_xlsx(prob_same_sector, "1-Intermediate_Processed_Data/prob_same_sector(at state level).xlsx")

# Transition probability
prob_same_state_sector_0  <- migration_1999_0 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(same_state_sector_0 = stay_in_num/l_1999)  %>% 
  select(state_ori, same_state_sector_0)  %>% 
  distinct(state_ori, same_state_sector_0, .keep_all = TRUE)

prob_same_state_sector_1  <- migration_1999_1 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(same_state_sector_1 = stay_in_num/l_1999)  %>% 
  select(state_ori, same_state_sector_1)  %>% 
  distinct(state_ori, same_state_sector_1, .keep_all = TRUE)

prob_same_state_sector_2  <- migration_1999_2 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(same_state_sector_2 = stay_in_num/l_1999)  %>% 
  select(state_ori, same_state_sector_2)  %>% 
  distinct(state_ori, same_state_sector_2, .keep_all = TRUE)

transition_prob  <- prob_same_state_sector_0  %>% 
  left_join(prob_same_state_sector_1, by = c('state_ori' = 'state_ori'))  %>% 
  left_join(prob_same_state_sector_2, by = c('state_ori' = 'state_ori')) 

transition_prob  <- transition_prob  %>% 
  left_join(prob_same_sector, by = c('state_ori' = 'state_ori'))  

transition_prob  <- transition_prob  %>% 
  left_join(prob_same_state, by = c('state_ori' = 'state_ori'))  

transition_prob  <- transition_prob  %>% 
  mutate(same_state_diff_sector_0 = stay_in_state_share_0 - same_state_sector_0)  %>% 
  mutate(same_state_diff_sector_1 = stay_in_state_share_1 - same_state_sector_1)  %>% 
  mutate(same_state_diff_sector_2 = stay_in_state_share_2 - same_state_sector_2)  %>% 
  mutate(diff_state_same_sector_0 = stay_in_sector_share_0 - same_state_sector_0)  %>% 
  mutate(diff_state_same_sector_1 = stay_in_sector_share_1 - same_state_sector_1)  %>% 
  mutate(diff_state_same_sector_2 = stay_in_sector_share_2 - same_state_sector_2)  %>% 
  select(state_ori, same_state_sector_0, same_state_sector_1, same_state_sector_2, same_state_diff_sector_0, same_state_diff_sector_1, same_state_diff_sector_2, diff_state_same_sector_0, diff_state_same_sector_1, diff_state_same_sector_2, stay_in_sector_share_0, stay_in_sector_share_1, stay_in_sector_share_2, stay_in_state_share_0, stay_in_state_share_1, stay_in_state_share_2) 

colnames(transition_prob)   <- gsub("same_state_sector", "same_state_same_sector", colnames(transition_prob))
colnames(transition_prob)   <- gsub("same_state_diff_sector", "chg_sector_not_state", colnames(transition_prob))
colnames(transition_prob)   <- gsub("diff_state_same_sector", "chg_state_not_sector", colnames(transition_prob))
  
cols_to_multiply  <- 2:16
for (col in cols_to_multiply) {
  transition_prob[, col] <- transition_prob[, col] * 100
}
write_xlsx(transition_prob, "1-Intermediate_Processed_Data/transition_prob(at state level).xlsx")

summary_pro  <- transition_prob  %>% 
  select(-state_ori)  %>% 
  mutate(across(everything(), list(Mean = mean, Max = max, Min = min, p25 = ~quantile(.,probs = 0.25), p50 = ~quantile(.,probs = 0.50), p75 = ~quantile(.,probs = 0.75))))  %>% 
  select(contains("Mean") | contains("Max") | contains("Min") | contains("p25") | contains("p50") | contains("p75"))  %>% 
  distinct()

summary_pro <- summary_pro %>%
  pivot_longer(cols = everything(), 
               names_to = c("state_sector", ".value"), 
               names_sep = "_(?=Mean|Max|Min|p25|p50|p75)") 
write_xlsx(summary_pro, "1-Intermediate_Processed_Data/yearly_summary_statistics(at state level).xlsx")

column <- transition_prob$chg_state_not_sector_2
cat("Mean:", mean(column), "\n")
cat("Maximum:", max(column), "\n")
cat("Minimum:", min(column), "\n")
cat("25th Percentile:", quantile(column, 0.25), "\n")
cat("50th Percentile (Median):", median(column), "\n")
cat("75th Percentile:", quantile(column, 0.75), "\n")

# Histogram
transition_prob  %>% 
  ggplot() +
  geom_histogram(aes(x = same_state_same_sector_2))


```


```{r transition probability at labour market level}
migration_1999_0  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case0.csv", sep=""), header = TRUE, sep = ",", dec = ".")
migration_1999_1  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case1.csv", sep=""), header = TRUE, sep = ",", dec = ".")
migration_1999_2  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_case2.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# Transition probability (at labour market level)
## Same state and sector
suffixes <- c("0", "1", "2")   # Define a vector of suffixes for the data frames
same_state_same_sector_list <- list()   # Create an empty list to store the results
columns_to_suffix <- c("same_state_same_sector")

for (suffix in suffixes) {    # Loop over the suffixes and process the data frames
  current_df <- get(paste0("migration_1999_", suffix))
  
  current_same_state_same_sector <- current_df %>%
    group_by(year, state_ori, sector_ori)  %>% 
    mutate(l_1999 = sum(level_employ))  %>% 
    mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori == sector_dest]))  %>% 
    ungroup()  %>% 
    mutate(same_state_same_sector = stay_in_num/l_1999)  %>% 
    select(state_ori, sector_ori, same_state_same_sector)  %>% 
    distinct(state_ori, sector_ori, same_state_same_sector, .keep_all = TRUE)

  colnames( current_same_state_same_sector)[colnames( current_same_state_same_sector) %in% columns_to_suffix] <-
    paste0(colnames( current_same_state_same_sector)[colnames( current_same_state_same_sector) %in% columns_to_suffix], "_", suffix)
  
  same_state_same_sector_list[[suffix]] <- current_same_state_same_sector
}

same_state_same_sector <- Reduce(function(x, y) left_join(x, y, by = c("state_ori", "sector_ori")), same_state_same_sector_list)  # Merge the results into a single data frame

## Changing state not sector
suffixes <- c("0", "1", "2")   # Define a vector of suffixes for the data frames
chg_state_not_sector_list <- list()   # Create an empty list to store the results
columns_to_suffix <- c("chg_state_not_sector")

for (suffix in suffixes) {    # Loop over the suffixes and process the data frames
  current_df <- get(paste0("migration_1999_", suffix))
  
  current_chg_state_not_sector <- current_df %>%
    group_by(year, state_ori, sector_ori)  %>% 
    mutate(l_1999 = sum(level_employ))  %>% 
    mutate(stay_in_num = sum(level_employ[state_ori != state_dest & sector_ori == sector_dest]))  %>% 
    ungroup()  %>% 
    mutate(chg_state_not_sector = stay_in_num/l_1999)  %>% 
    select(state_ori, sector_ori, chg_state_not_sector)  %>% 
    distinct(state_ori, sector_ori, chg_state_not_sector, .keep_all = TRUE)

  colnames( current_chg_state_not_sector)[colnames( current_chg_state_not_sector) %in% columns_to_suffix] <-
    paste0(colnames( current_chg_state_not_sector)[colnames( current_chg_state_not_sector) %in% columns_to_suffix], "_", suffix)
  
  chg_state_not_sector_list[[suffix]] <- current_chg_state_not_sector
}

chg_state_not_sector <- Reduce(function(x, y) left_join(x, y, by = c("state_ori", "sector_ori")), chg_state_not_sector_list)  # Merge the results into a single data frame

## Changing sector not state
suffixes <- c("0", "1", "2")   # Define a vector of suffixes for the data frames
chg_sector_not_state_list <- list()   # Create an empty list to store the results
columns_to_suffix <- c("chg_sector_not_state")

for (suffix in suffixes) {    # Loop over the suffixes and process the data frames
  current_df <- get(paste0("migration_1999_", suffix))
  
  current_chg_sector_not_state <- current_df %>%
    group_by(year, state_ori, sector_ori)  %>% 
    mutate(l_1999 = sum(level_employ))  %>% 
    mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori != sector_dest]))  %>% 
    ungroup()  %>% 
    mutate(chg_sector_not_state = stay_in_num/l_1999)  %>% 
    select(state_ori, sector_ori, chg_sector_not_state)  %>% 
    distinct(state_ori, sector_ori, chg_sector_not_state, .keep_all = TRUE)

  colnames( current_chg_sector_not_state)[colnames( current_chg_sector_not_state) %in% columns_to_suffix] <-
    paste0(colnames( current_chg_sector_not_state)[colnames( current_chg_sector_not_state) %in% columns_to_suffix], "_", suffix)
  
  chg_sector_not_state_list[[suffix]] <- current_chg_sector_not_state
}

chg_sector_not_state <- Reduce(function(x, y) left_join(x, y, by = c("state_ori", "sector_ori")), chg_sector_not_state_list)  

## Changing sector changing state
suffixes <- c("0", "1", "2")   # Define a vector of suffixes for the data frames
chg_state_chg_sector_list <- list()   # Create an empty list to store the results
columns_to_suffix <- c("chg_state_chg_sector")

for (suffix in suffixes) {    # Loop over the suffixes and process the data frames
  current_df <- get(paste0("migration_1999_", suffix))
  
  current_chg_state_chg_sector <- current_df %>%
    group_by(year, state_ori, sector_ori)  %>% 
    mutate(l_1999 = sum(level_employ))  %>% 
    mutate(stay_in_num = sum(level_employ[state_ori != state_dest & sector_ori != sector_dest]))  %>% 
    ungroup()  %>% 
    mutate(chg_state_chg_sector = stay_in_num/l_1999)  %>% 
    select(state_ori, sector_ori, chg_state_chg_sector)  %>% 
    distinct(state_ori, sector_ori, chg_state_chg_sector, .keep_all = TRUE)

  colnames( current_chg_state_chg_sector)[colnames( current_chg_state_chg_sector) %in% columns_to_suffix] <-
    paste0(colnames( current_chg_state_chg_sector)[colnames( current_chg_state_chg_sector) %in% columns_to_suffix], "_", suffix)
  
  chg_state_chg_sector_list[[suffix]] <- current_chg_state_chg_sector
}

chg_state_chg_sector <- Reduce(function(x, y) left_join(x, y, by = c("state_ori", "sector_ori")), chg_state_chg_sector_list)  

transition_prob  <- same_state_same_sector  %>% 
  left_join(chg_sector_not_state, by = c('state_ori', 'sector_ori'))  %>% 
  left_join(chg_state_not_sector, by = c('state_ori', 'sector_ori'))  %>% 
  left_join(chg_state_chg_sector, by = c('state_ori', 'sector_ori')) 

cols_to_multiply  <- 3:14
for (col in cols_to_multiply) {
  transition_prob[, col] <- transition_prob[, col] * 100
}
write_xlsx(transition_prob, "1-Intermediate_Processed_Data/transition_prob_yearly(at state sector level).xlsx")

summary_pro  <- transition_prob  %>% 
  select(-state_ori, -sector_ori)  %>% 
  mutate(across(everything(), list(Mean = mean, Max = max, Min = min, p25 = ~quantile(.,probs = 0.25), p50 = ~quantile(.,probs = 0.50), p75 = ~quantile(.,probs = 0.75))))  %>% 
  select(contains("Mean") | contains("Max") | contains("Min") | contains("p25") | contains("p50") | contains("p75"))  %>% 
  distinct()

summary_pro <- summary_pro %>%
  pivot_longer(cols = everything(), 
               names_to = c("state_sector", ".value"), 
               names_sep = "_(?=Mean|Max|Min|p25|p50|p75)") 
write_xlsx(summary_pro, "1-Intermediate_Processed_Data/summary_statistics_yearly(at state sector level).xlsx")

column <- transition_prob$chg_state_not_sector_2
cat("Mean:", mean(column), "\n")
cat("Maximum:", max(column), "\n")
cat("Minimum:", min(column), "\n")
cat("25th Percentile:", quantile(column, 0.25), "\n")
cat("50th Percentile (Median):", median(column), "\n")
cat("75th Percentile:", quantile(column, 0.75), "\n")

# Histogram
transition_prob  %>% 
  ggplot() +
  geom_histogram(aes(x = same_state_same_sector_2))



```


