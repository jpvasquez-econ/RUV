---
title: "State-Country Bilateral Trade"
output:
  html_document:
    df_print: paged
  pdf_document:
    number_sections: yes
header-includes:
- \usepackage{amsmath}
- \usepackage{amssymb}
- \usepackage{pifont}
- \usepackage{mathpazo}
- \newcommand{\xmark}{\ding{55}}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
remove(list = ls())
```

```{r warning=FALSE, include=FALSE, message=FALSE, results='hide', cache=FALSE}
# libraries
options( scipen=100, stringsAsFactors=FALSE );
# vector of libraries to be used
libs <- c( 'dplyr', 'tidyr', 'readstata13', 'haven', 'stringr', 'nleqslv', 'gdata', 'Statamarkdown', 'foreign');
# Install libraries in case they are not installed
for( i in length(libs)){ 
  if( !(libs[i] %in% installed.packages()) ) install.packages( libs ) 
};
# Carga de bibliotecas
lapply( libs, require, character.only=TRUE );
```

## General Instructions

To use $X_{ij,k}^{Base}$ and $X_{ij,k}^{WIOD}$ plus proportionality to calculate $X_{ij,k}^{year}$ for $i\in US\;  \&\;  j \notin US$ (exports from each State to each country) and $i\notin US\;  \&\;  j \in US$ (imports from each country to each State), and $\forall k=1,...,12$.  I call the output of this part $X_{ij,k}^{Step3}$. $Base=2002$ for exports and $Base=2008$ for imports. 


## Importing datasets to R
```{r}
#state level imports and exports
state_imp_exp.0 <- read_dta("1-Intermediate_Processed_Data//state_imports_exports.dta")
state_imp_exp.0 <- state_imp_exp.0 %>%
  mutate(origin= recode(origin, "New Hampshire"="NewHampshire", "New Jersey"="NewJersey", "New Mexico"="NewMexico", "New York"="NewYork", "North Carolina"="NorthCarolina", "North Dakota"="NorthDakota", "Rhode Island"="RhodeIsland", "South Carolina"="SouthCarolina", "South Dakota"="SouthDakota", "West Virginia"="WestVirginia")) %>%
  mutate(destination= recode(destination, "New Hampshire"="NewHampshire", "New Jersey"="NewJersey", "New Mexico"="NewMexico", "New York"="NewYork", "North Carolina"="NorthCarolina", "North Dakota"="NorthDakota", "Rhode Island"="RhodeIsland", "South Carolina"="SouthCarolina", "South Dakota"="SouthDakota", "West Virginia"="WestVirginia"))
#WIOD
WIOD.base <- read_dta("1-Intermediate_Processed_Data//WIOD_countries.dta")
#General parameters
n.s=50
n.c=37
#state names
states <- read.csv("1-Intermediate_Processed_Data//state_cfs_step_2000.txt", header = TRUE, sep = ",", dec = ".")
names.states=matrix(states$importer[1:n.s])
#country names
countries <- read.csv("1-Intermediate_Processed_Data//country_country_step_2000.txt", header = TRUE, sep = ",", dec = ".")
names.countries=matrix(countries$importer[1:n.c])

num.sec <- 12
epsilon<-0.0001;

```


## Step 3

### Construction of intermediate variables
Define the share of exports of US State $i$ in sector $k$, going to country $j$ as: $$y_{ij,k}^{Base}\equiv\dfrac{X_{ij,k}^{Base}}{\sum_{h\in US}X_{hj,k}^{Base}} \; \forall i\in US \, , \, j\notin US.$$ For example, for the case of $i=$California y $j=$ China, $y_{ij,k}^{Base}$  is the share of exports that go from California to China relative to all the exports that go from the US to China.

Similarly, only for $j \in US$ define the share of imports of State $j$ in sector $k$, coming from country $i$ as
$$e_{ij,k}^{Base}\equiv\dfrac{X_{ij,k}^{Base}}{\sum_{l\in US}X_{il,k}^{Base}}. \; \forall i\notin US \, , \, j\in US.$$ For example, for the case of $i=$China y $j=$California, $e_{ij,k}^{Base}$  is the share of imports that come from China to California relative to all the imports that go from China to the US. 

Note that despite this subtask being similar to the one in the "bilat_creation_MM" file, it is unlikely that the code could be recycled since the file containing $X_{ij,k}^{Base}$ has a totally different format. 


### Main variable
Define $\forall k$: $$
X_{ij,k}^{step3}=
\begin{cases}
e_{ij,k}^{Base}X_{i\,US,k}^{WIOD} \quad \forall i\notin US, \; \forall j\in US\\
y_{ij,k}^{Base}X_{US\,j,k}^{WIOD} \quad \forall i\in US, \; \forall j\notin US
\end{cases} $$

### check that the following conditions hold
\begin{enumerate}
\item For $j\neq US$ we should $\sum_{i\in US}X_{ij,k}^{step3}=X_{US\,j,k}^{WIOD} \; \forall j, k=1,...,12$
\item For $i\notin US$ we should $\sum_{j\in US}X_{ij,k}^{step3}=X_{i\,US,k}^{WIOD} \; \forall i,k=1,...,12$
\end{enumerate}

#### Correcting: US import from j, sector k (WIOD registers imports, but st-imp-exp doesn't)

Then, for $i=SVN$, $j \in US$, y $k=4$:
$$
e_{SVN\;j,4}^{census}\equiv\dfrac{\sum_{i\notin US}X_{ij,4}^{census}}{\sum_{h\notin US}\sum_{l\in US}X_{hl,4}^{census}}. \nonumber
$$

#### Correcting: US export from i, sector k (WIOD registers exports, but st-imp-exp doesn't)

Then, for $i=SVN$, $j \in US$, y $k=4$:
$$
y_{i\;SVN,4}^{census}\equiv\dfrac{\sum_{j\notin US}X_{ij,4}^{census}}{\sum_{h\in US}\sum_{l\notin US}X_{hl,4}^{census}}. \nonumber
$$

#### Imports
```{r}
### Base year for imports (2008)
state_imp_exp <- data.frame(state_imp_exp.0) %>% 
  filter(year==2008, file=="i not in US, j in US", origin!="All States", destination!="All States") %>%
  select(-year, -file)

state_imp_exp <-spread(state_imp_exp, origin, value, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)
Base.e <- state_imp_exp %>% 
  arrange(sector, destination) %>%
  filter(sector<=12)

colnames(Base.e)= c("importer", "sector", names.countries)
Base.e[is.na(Base.e)] <- 0


for (yr in 2000:2007) {

#WIOD
WIOD <- subset(WIOD.base, year==yr)
WIOD <- subset(WIOD, select = -year) 


##################################################

eijkBase <- melt(Base.e, id.vars=c("importer", "sector"), variable.name="origin", value.name = "value")
eijkBase <-spread(eijkBase, importer, value, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)
eijkBase <- eijkBase[, 3:dim(eijkBase)[2]] / rowSums(eijkBase[, 3:dim(eijkBase)[2]]) 


#######################################Main Variable
#e
df.WIOD = data.frame(WIOD)
df.WIOD <- df.WIOD %>%
  filter(sector<=12) %>%
  filter(importer_country=='USA')
df.WIOD1 <- df.WIOD %>% select(-value_USA, -importer, -importer_country)
colnames(df.WIOD1) <- c("sector", names.countries)
df.WIOD1 <- melt(df.WIOD1, id.vars=c("sector"), variable.name="origin", value.name = "value")
df.WIOD1 <- df.WIOD1 %>% arrange(sector, origin)

step3e=eijkBase*df.WIOD1$value
step3e <- cbind(df.WIOD1[, 1:2], step3e)


#Check
check= as.matrix(rowSums(step3e[, 3:dim(step3e)[2]]) - df.WIOD1$value)

##############################
#Correcting if needed
m.correct <- c()
for (sec in 1:12) {
m <- Base.e %>% filter(sector==sec)
m <- (rowSums(m[, 3:dim(m)[2]]) / sum(m[, 3:dim(m)[2]]))
m= t(matrix(replicate(n.c, m), nrow = length(m), ncol = n.c))
m.correct <- rbind(m.correct, m) 
}
m.correct <- m.correct*df.WIOD1$value

for (r in 1:(dim(check)[1])) {
  if(is.na(check[r])==TRUE){step3e[r, 3:dim(step3e)[2]] = m.correct[r, ]}
}

if(abs(sum(rowSums(step3e[, 3:dim(step3e)[2]]) - df.WIOD1$value))>epsilon) 
   stop(paste("states' imports from countries != WIOD US imports from countries for", yr, " value=", abs(sum(step3e[, 3:dim(step3e)[2]] - df.WIOD1$value))))
################

step3e <- melt(step3e, id.vars=c("origin", "sector"), variable.name="importer", value.name = "value")
step3e <-spread(step3e, origin, value, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

step3e <- step3e %>%
  mutate(year=yr) %>%
  select(year, importer, sector, everything())

  #Exporting dataset
write.table(step3e, file = paste("1-Intermediate_Processed_Data//state_country_step_e_", yr,".txt", sep=""), sep = ",", row.names = FALSE)
}

```


#### Exports
```{r}

for (yr in 2000:2007) {

#WIOD
WIOD <- subset(WIOD.base, year==yr)
WIOD <- subset(WIOD, select = -year) 


#Base year for exports (2002)
yr.=yr
if(yr<2002){yr.=2002}
state_imp_exp <- data.frame(state_imp_exp.0) %>% 
  filter(year==yr., file=="i in US, j not in US", origin!="All States", destination!="All States") %>%
  select(-year, -file)
state_imp_exp <-spread(state_imp_exp, origin, value, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)
#no trade from US states to SVK in sector 4 in 2002
if(yr<=2002) {row <- c("SVK", 4L, matrix(0, nrow=1, ncol=50))
state_imp_exp <- rbind(state_imp_exp, row)}
state_imp_exp$sector <- as.numeric(state_imp_exp$sector)

Base.y <- state_imp_exp %>% 
  arrange(sector, destination) %>%
  filter(sector<=12)
colnames(Base.y)= c("importer", "sector", names.states)
Base.y[is.na(Base.y)] <- 0
Base.y <- cbind(Base.y[, 1:2], mapply(Base.y[, 3:dim(Base.y)[2]], FUN=as.numeric))


##################################################

##################################################

yijkBase <- Base.y[, 3:dim(Base.y)[2]] / rowSums(Base.y[, 3:dim(Base.y)[2]]) 

############################### Main variable
#y
df.WIOD = data.frame(WIOD)
df.WIOD <- df.WIOD %>%
  filter(sector<=12) %>%
  filter(importer_country!='USA') 

df.WIOD1 <- df.WIOD %>% select(importer_country, sector, value_USA)

step3y <- yijkBase*df.WIOD1$value_USA
step3y <- cbind(df.WIOD1[, 1:2], step3y)

#Check
check= as.matrix(rowSums(step3y[, 3:dim(step3y)[2]]) - df.WIOD1$value_USA)


##############################
#Correcting if needed
Base.y1 <- melt(Base.y, id.vars=c("importer", "sector"), variable.name="origin", value.name = "value")
Base.y1 <-spread(Base.y1, importer, value, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

m.correct <- c()
for (sec in 1:12) {
m <- Base.y1 %>% filter(sector==sec)
m <- (rowSums(m[, 3:dim(m)[2]]) / sum(m[, 3:dim(m)[2]]))
m= t(matrix(replicate(n.c, m), nrow = length(m), ncol = n.c))
m.correct <- rbind(m.correct, m) 
}
m.correct <- m.correct*df.WIOD1$value_USA

for (r in 1:(dim(check)[1])) {
  if(is.na(check[r])==TRUE){step3y[r, 3:dim(step3y)[2]] = m.correct[r, ]}
}

if(abs(sum(rowSums(step3y[, 3:dim(step3y)[2]]) - df.WIOD1$value_USA))>epsilon) 
   stop(paste("states' exports to countries != WIOD US exports to countries for", yr, " value=", abs(sum(step3y[, 3:dim(step3y)[2]] - df.WIOD1$value))))
################

step3y <- step3y %>%
  mutate(year=yr) %>%
  select(year, importer_country, sector, everything())
colnames(step3y) <- c("year", "importer", "sector", names.states)

#Exporting data
write.table(step3y, file = paste("1-Intermediate_Processed_Data//state_country_step_y_", yr,".txt", sep=""), sep = ",", row.names = FALSE)
}
```






