---
title: "IRS data and migration matrix"
author: "Yuanhang(Leo) Yu"
date: "2023-05-26"
output:
  html_document:
    toc: yes
    df_print: paged
  # pdf_document:
    # number_sections: yes
  # html_notebook:
    # toc: yes
    # df_print: paged
    # number_sections: yes
header-includes:
- \usepackage{amsmath}
- \usepackage{amssymb}
- \usepackage{pifont}
- \usepackage{mathpazo}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
remove(list = ls())  
```

```{r message=FALSE, warning=FALSE, cache=FALSE, include=FALSE, results='hide'}
# libraries
options( scipen=100, digits = 15, stringsAsFactors=FALSE ); # no scientific notation, up to 15 digits 

# vector of libraries to be used
libs <- c( 'dplyr', 'tidyr', 'haven', 'stringr', 'nleqslv', 'gdata', 'formattable', 'ggplot2', 'viridis', 'RColorBrewer', 'reshape2', 'foreign', 'readxl', 'writexl', 'rjson', 'read_excel', 'Matrix', 'geodist', 'readr', 'data.table', 'stringr', 'haven');
# Install libraries in case they are not installed
for( i in seq_along(libs)){ 
    if( !(libs[i] %in% installed.packages()) ) install.packages( libs[i] ) 
};
# Loading libraries
lapply( libs, require, character.only=TRUE );
```

## IRS data

This section processes the county-level IRS migration data.

```{r include=FALSE}
 
######## This part cleans the county-by-county IRS data ########## 

irs_temp  <- read_dta("0-Raw_Data/IRS/1999to2000CountyMigration/1999to2000flow.dta")

state_name  <- c("Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut", "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "NewHampshire", "NewJersey", "NewMexico", "NewYork", "NorthCarolina", "NorthDakota", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "RhodeIsland", "SouthCarolina", "SouthDakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "WestVirginia", "Wisconsin", "Wyoming")

all_combo <- c()
for (state in state_name) {
temp <- data.frame(state_name) #list of regions
temp <- temp %>%
  dplyr::rename(state_ori = state_name) %>%
  mutate(state_dest = state)  #create destination state and sector
all_combo <- bind_rows(all_combo, temp) #add all together, therefore all combination 
}

irs  <- all_combo %>% 
  left_join(irs_temp, by = c('state_dest' = 'state_dest', 'state_ori' = 'state_ori'))  %>% 
  mutate(year = 1999)  %>% 
  mutate(exemption = ifelse(is.na(exemption), 0, exemption))

write.table(irs, file = paste("1-Intermediate_Processed_Data//irs.csv", sep=""), sep = ",", row.names = FALSE) 

```

## Proportionality assumption with IRS data: final case IRS version 4

### Migration matrix with IRS 
Within the State
$$
L^{n j, n k}=L_{I R S}^{n, n} \times \frac{L_{C P S}^{n j, n k}}{\sum_q \sum_h L_{C P S}^{n h, n q}} \quad \forall n \in U S A, \forall j, k
$$
Between States
$$
L^{n j, i k}=\frac{L_{A C S}^{n \#, i k}}{\sum_q L_{A C S}^{n \#, i q}} \times L_{I R S}^{n, i} \times \frac{L_{C P S}^{i j, i k}}{\sum_h L_{C P S}^{i h, i k}} \quad (n \neq i)
$$
```{r}
# loading intermediate CPS
cps <- read.csv(paste("1-Intermediate_Processed_Data//cps_2.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# within states proportionality
temp_within  <- cps %>%           # create the cps share for within state expression
  filter(state_ori == state_dest & year == 1999)  %>% 
  group_by(year, state_dest, state_ori)  %>% 
  mutate(n_cps_two_states_tot = sum(n_cps))  %>% 
  ungroup()  %>% 
  mutate(cps_share_wti = n_cps/n_cps_two_states_tot) %>% 
  select(year, state_ori, state_dest, sector_ori, sector_dest, cps_share_wti)

# between states proportionality
temp_between_cps  <- cps  %>%    # create the cps share for between state expression
  filter(state_ori == state_dest & year == 1999)  %>% 
  group_by(year, state_dest, state_ori, sector_dest)  %>% 
  mutate(n_cps_same_sector_dest = sum(n_cps))  %>% 
  ungroup()  %>% 
  mutate(cps_share_btw = n_cps/n_cps_same_sector_dest)  %>% 
  select(year, state_ori, state_dest, sector_ori, sector_dest, cps_share_btw)

acs <- read.csv(paste("1-Intermediate_Processed_Data//acs.csv", sep=""), header = TRUE, sep = ",", dec = ".")

temp_between_acs  <-  acs  %>%  # create the acs share for between state expression
  filter(year == 1999)  %>% 
  group_by(year, state_dest, state_ori)  %>% 
  mutate(n_acs_two_tot = sum(n_acs))  %>% 
  ungroup()  %>% 
  mutate(acs_share = n_acs/n_acs_two_tot)  %>% 
  mutate(acs_share = ifelse(is.na(acs_share), 0, acs_share))  %>% 
  select(year, state_ori, state_dest, sector_dest, acs_share)

mobility  <- cps  %>%   # adjusted migration flows
  filter(year == 1999)  %>% 
  left_join(irs, by=c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori')) %>%
  left_join(temp_within, by = c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest', 'sector_ori' = 'sector_ori'))  %>% 
  left_join(temp_between_acs, by = c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest'))  %>% 
  left_join(temp_between_cps, by = c('year' = 'year', 'state_dest' = 'state_dest', 'sector_dest' = 'sector_dest', 'sector_ori' = 'sector_ori'))  %>% 
  rename(state_ori = state_ori.x)  %>% 
  mutate(n_cps_adj = exemption * acs_share * cps_share_btw)  %>% 
  mutate(n_cps_adj = ifelse(state_ori == state_dest, exemption*cps_share_wti, n_cps_adj))  %>% 
  select(-state_ori.y)

# mu_1999 prime for L_1999
# the second part of this calculation is in the next step since there is an additional proportionality that has to be implemented in L_2000 so that it is consistent with WIOD
mu_1999_prime <- mobility %>%
  group_by(year, state_dest, sector_dest) %>% 
  mutate(tot_n = sum(n_cps_adj)) %>% # total inflows to destination state-sector
  ungroup() %>%
  mutate(rel = n_cps_adj/tot_n) %>%  #(inflow share of destination state-sector across original state-sector) rel: share of people from original state-sector pairs to the same destination state-sector
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel)

# mu_1999 prime for L_1999
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars = c("state"), variable.name = "sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector)))
mu_1999_prime <- mu_1999_prime %>%
  left_join(L_2000, by=c('state_dest' = 'state', 'sector_dest' = 'sector')) %>% 
  mutate(level_employ = rel*employ) %>%   # generate the 1999 migration flows based on the 2000 distribution and 1999 migration share
  select(-rel, -employ)
write.table(mu_1999_prime, file = paste("1-Intermediate_Processed_Data/mu_1999_prime_irs_4.csv", sep=""), sep = ",", row.names = FALSE)

# Computing L_1999 using mobility matrices and L_2000
L_1999 <- mu_1999_prime %>%
  group_by(state_ori, sector_ori) %>%
  mutate(employ = sum(level_employ)) %>%  # 1999 labour distribution
  ungroup() %>%
  distinct(state_ori, sector_ori, .keep_all = TRUE) %>%
  dplyr::rename(state = state_ori, sector = sector_ori) %>%
  select(state, sector, employ) %>%
  arrange(state, sector)
temp_L_1999 <- L_1999
L_1999 <- spread(L_1999, sector, employ, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)
write.table(L_1999, file = paste("1-Intermediate_Processed_Data/L_1999_irs_4.csv", sep=""), sep = ",", row.names = FALSE)

# Recalculating mu_1999 and checking flow 1999-2000
mu_1999 <- mu_1999_prime %>% 
  dplyr::rename(n_cps_adj_ = level_employ) %>%
  group_by(year, state_ori, sector_ori) %>% 
  mutate(tot_n_cps_accros_dest = sum(n_cps_adj_)) %>% 
  ungroup() %>%
  mutate(rel = n_cps_adj_/tot_n_cps_accros_dest) %>% # migration (out) share in 1999
  distinct(state_dest, state_ori, sector_dest, sector_ori, .keep_all = TRUE) %>% 
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel) %>%
  arrange(year, state_ori, sector_ori, state_dest, sector_dest)
write_xlsx(mu_1999, path = paste("1-Intermediate_Processed_Data/mu_1999_irs_4_long_format.xlsx", sep=""))
mu_1999 <- mu_1999 %>%
  mutate(sector_dest = recode(as.character(sector_dest), '0' ="00", '1' ="01", '2' ="02", '3' ="03", '4' ="04", '5' ="05", '6' ="06", '7' ="07", '8' ="08", '9' ="09" )) %>%
  mutate(state_dest_sector_dest = paste(state_dest, sector_dest, sep="_")) %>%
  select(-state_dest, -sector_dest)
mu_1999 <- spread(mu_1999, state_dest_sector_dest, rel, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# check sum(prob)==1
epsilon <- 0.01
check <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
if(sum(abs(as.matrix(rowSums(check)) - matrix(1, dim(check)[1], 1))) > epsilon) 
  stop("mobility shares do not add to 1")
write_xlsx(mu_1999, path = paste("2-Final_Data/mu_1999_irs_4.xlsx", sep=""))

# check L_1999 and mu_1999 gives L_2000
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars=c("state"), variable.name="sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector))) %>%
  arrange(state, sector)
L_2000 <- as.matrix(L_2000$employ)
L_1999 <- as.matrix(temp_L_1999$employ)
mu_1999 <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
mu_1999 <- as.matrix(mu_1999)
if(sum(L_2000 - (t(mu_1999)%*%L_1999)) > epsilon) 
  stop(paste("L_1999 and mu_1999 do NOT give L_2000"))

```

## Comparison of different migration matrices
I compare three different matrices based on different method of proportionality
  - Case 0: Original matrix with CPS and ACS without modification on the diagonal
  
$$
L^{nj,ik}=\sum_{q}L_{ACS}^{n?,iq}\times\frac{L_{CPS}^{ij,ik}}{\sum_{q}\sum_{h}L_{CPS}^{ih,iq}}\quad\forall n,i\in US;\,\forall j,k
$$

  - Case 1: Original matrix with CPS and ACS with modified diagonal proportionality (see 3.1 on the migration_math.lyx)
  
$$
L^{nj,ik}=\sum_{q}L_{ACS}^{n?,iq}\times\frac{L_{CPS}^{ij,ik}}{\sum_{q}\sum_{h}L_{CPS}^{ih,iq}}\quad\forall n,i\in US;\,\forall j,k
$$
  - Case 2: Matrix with IRS version 4 (see section New: June 11th) 
  
$$
L^{nj,nk}=L_{IRS}^{n,n}\times\frac{L_{CPS}^{nj,nk}}{\sum_{q}\sum_{h}L_{CPS}^{nh,nq}} \quad \forall n\in USA,\forall j,k  \\
L^{nj,ik}=\frac{L_{CPS}^{ij,ik}}{\sum_{h}L_{CPS}^{ih,ik}}\times L_{IRS}^{n,i}\times\frac{L_{ACS}^{n\#,ik}}{\sum_{q}L_{ACS}^{n\#,iq}}
$$

### Add code produced case 0 and case 1 for simplicity

```{r}
#### Case 0 ####
# loading intermediate CPS
cps <- read.csv(paste("1-Intermediate_Processed_Data//cps_2_0.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# loading intermediate ACS
acs <- read.csv(paste("1-Intermediate_Processed_Data//acs.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# Mobility matrices
# disaggregating ACS data using CPS sector_ori info and computation of mobility share
# origin in rows and destination in columns
# row shares sum to 1
acs <- acs %>%
  group_by(year, state_ori, state_dest) %>%
  mutate(n_acs = sum(n_acs)) %>% # n_acs: for (state_ori, state_dest) pair, n_acs is the total migration summed over all destination sectors
  ungroup() %>%
  distinct(year, state_ori, state_dest, .keep_all = TRUE) %>%
  select(-sector_dest)  # total migration from state i to state j for each (i,j) combination

# adjusting x's to y's: cps migration pair share times total migration from acs
mobility <- cps %>%
  left_join(acs, by=c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori')) %>%
  group_by(year, state_dest, state_ori) %>% 
  mutate(tot_n_cps_accros_sec = sum(n_cps)) %>% # totol within destination state migration (sum over all sector movements)
  ungroup() %>%
  mutate(n_cps_adj = n_cps/tot_n_cps_accros_sec) %>% # migration share across sectors within state (based on destination state)
  mutate(n_cps_adj = ifelse(is.na(n_cps_adj) == TRUE, 0, n_cps_adj)) %>%
  mutate(n_cps_adj = n_cps_adj*n_acs) %>% # use cps within-state across sector migration share times acs total migration across states
  select(-tot_n_cps_accros_sec, -n_cps, -n_acs) 

# mu_1999 prime for L_1999
# the second part of this calculation is in the next step since there is an additional proportionality that has to be implemented in L_2000 so that it is consistent with WIOD
mu_1999_prime <- mobility %>%
  filter(year == 1999) %>%
  group_by(year, state_dest, sector_dest) %>% 
  mutate(tot_n = sum(n_cps_adj)) %>% # total inflows to destination state-sector
  ungroup() %>%
  mutate(rel = n_cps_adj/tot_n) %>%  # (inflow share of destination state-sector across original state-sector)rel: share of people from original state-sector pairs to the same destination state-sector
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel)

# mu_1999 prime for L_1999
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars = c("state"), variable.name = "sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector)))
mu_1999_prime <- mu_1999_prime %>%
  left_join(L_2000, by=c('state_dest' = 'state', 'sector_dest' = 'sector')) %>% 
  mutate(level_employ = rel*employ) %>%   # generate the 1999 migration flows based on the 2000 distribution and 1999 migration share
  select(-rel, -employ)
write.table(mu_1999_prime, file = paste("1-Intermediate_Processed_Data/mu_1999_prime_0.csv", sep=""), sep = ",", row.names = FALSE)

# Computing L_1999 using mobility matrices and L_2000
L_1999 <- mu_1999_prime %>%
  group_by(state_ori, sector_ori) %>%
  mutate(employ = sum(level_employ)) %>%  # 1999 labour distribution
  ungroup() %>%
  distinct(state_ori, sector_ori, .keep_all = TRUE) %>%
  dplyr::rename(state = state_ori, sector = sector_ori) %>%
  select(state, sector, employ) %>%
  arrange(state, sector)
temp_L_1999 <- L_1999
L_1999 <- spread(L_1999, sector, employ, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# Recalculating mu_1999 and checking flow 1999-2000
mu_1999 <- mu_1999_prime %>% 
  dplyr::rename(n_cps_adj_ = level_employ) %>%
  group_by(year, state_ori, sector_ori) %>% 
  mutate(tot_n_cps_accros_dest = sum(n_cps_adj_)) %>% 
  ungroup() %>%
  mutate(rel = n_cps_adj_/tot_n_cps_accros_dest) %>% # migration (out) share in 1999
  distinct(state_dest, state_ori, sector_dest, sector_ori, .keep_all = TRUE) %>% 
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel) %>%
  arrange(year, state_ori, sector_ori, state_dest, sector_dest)
write_xlsx(mu_1999, path = paste("1-Intermediate_Processed_Data/mu_1999_0_long_format.xlsx", sep=""))
mu_1999 <- mu_1999 %>%
  mutate(sector_dest = recode(as.character(sector_dest), '0' ="00", '1' ="01", '2' ="02", '3' ="03", '4' ="04", '5' ="05", '6' ="06", '7' ="07", '8' ="08", '9' ="09" )) %>%
  mutate(state_dest_sector_dest = paste(state_dest, sector_dest, sep="_")) %>%
  select(-state_dest, -sector_dest)
mu_1999 <- spread(mu_1999, state_dest_sector_dest, rel, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# check sum(prob)==1
epsilon <- 0.01
check <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
if(sum(abs(as.matrix(rowSums(check)) - matrix(1, dim(check)[1], 1))) > epsilon) 
  stop("mobility shares do not add to 1")
write_xlsx(mu_1999, path = paste("2-Final_Data/mu_1999_0.xlsx", sep=""))

# check L_1999 and mu_1999 gives L_2000
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars=c("state"), variable.name="sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector))) %>%
  arrange(state, sector)
L_2000 <- as.matrix(L_2000$employ)
L_1999 <- as.matrix(temp_L_1999$employ)
mu_1999 <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
mu_1999 <- as.matrix(mu_1999)
if(sum(L_2000 - (t(mu_1999)%*%L_1999)) > epsilon) 
  stop(paste("L_1999 and mu_1999 do NOT give L_2000"))


#### Case 1 ####
# loading intermediate CPS
cps <- read.csv(paste("1-Intermediate_Processed_Data//cps_2.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# loading intermediate ACS
acs <- read.csv(paste("1-Intermediate_Processed_Data//acs.csv", sep=""), header = TRUE, sep = ",", dec = ".")

# Mobility matrices
# disaggregating ACS data using CPS sector_ori info and computation of mobility share
# origin in rows and destination in columns
# row shares sum to 1
acs <- acs %>%
  group_by(year, state_ori, state_dest) %>%
  mutate(n_acs = sum(n_acs)) %>% # n_acs: for (state_ori, state_dest) pair, n_acs is the total migration summed over all destination sectors
  ungroup() %>%
  distinct(year, state_ori, state_dest, .keep_all = TRUE) %>%
  select(-sector_dest)  # total migration from state i to state j for each (i,j) combination

# adjusting x's to y's: cps migration pair share times total migration from acs
mobility <- cps %>%
  left_join(acs, by=c('year' = 'year', 'state_dest' = 'state_dest', 'state_ori' = 'state_ori')) %>%
  group_by(year, state_dest, state_ori) %>% 
  mutate(tot_n_cps_accros_sec = sum(n_cps)) %>% # totol within destination state migration (sum over all sector movements)
  ungroup() %>%
  mutate(n_cps_adj = n_cps/tot_n_cps_accros_sec) %>% # migration share across sectors within state (based on destination state)
  mutate(n_cps_adj = ifelse(is.na(n_cps_adj) == TRUE, 0, n_cps_adj)) %>%
  mutate(n_cps_adj = n_cps_adj*n_acs) %>% # use cps within-state across sector migration share times acs total migration across states
  select(-tot_n_cps_accros_sec, -n_cps, -n_acs) 

# mu_1999 prime for L_1999
# the second part of this calculation is in the next step since there is an additional proportionality that has to be implemented in L_2000 so that it is consistent with WIOD
mu_1999_prime <- mobility %>%
  filter(year == 1999) %>%
  group_by(year, state_dest, sector_dest) %>% 
  mutate(tot_n = sum(n_cps_adj)) %>% # total inflows to destination state-sector
  ungroup() %>%
  mutate(rel = n_cps_adj/tot_n) %>%  # (inflow share of destination state-sector across original state-sector)rel: share of people from original state-sector pairs to the same destination state-sector
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel)

# mu_1999 prime for L_1999
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars = c("state"), variable.name = "sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector)))
mu_1999_prime <- mu_1999_prime %>%
  left_join(L_2000, by=c('state_dest' = 'state', 'sector_dest' = 'sector')) %>% 
  mutate(level_employ = rel*employ) %>%   # generate the 1999 migration flows based on the 2000 distribution and 1999 migration share
  select(-rel, -employ)
write.table(mu_1999_prime, file = paste("1-Intermediate_Processed_Data/mu_1999_prime.csv", sep=""), sep = ",", row.names = FALSE)

# Computing L_1999 using mobility matrices and L_2000
L_1999 <- mu_1999_prime %>%
  group_by(state_ori, sector_ori) %>%
  mutate(employ = sum(level_employ)) %>%  # 1999 labour distribution
  ungroup() %>%
  distinct(state_ori, sector_ori, .keep_all = TRUE) %>%
  dplyr::rename(state = state_ori, sector = sector_ori) %>%
  select(state, sector, employ) %>%
  arrange(state, sector)
temp_L_1999 <- L_1999
L_1999 <- spread(L_1999, sector, employ, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)
# write.table(L_1999, file = paste("1-Intermediate_Processed_Data/L_1999.csv", sep=""), sep = ",", row.names = FALSE)

# Recalculating mu_1999 and checking flow 1999-2000
mu_1999 <- mu_1999_prime %>% 
  dplyr::rename(n_cps_adj_ = level_employ) %>%
  group_by(year, state_ori, sector_ori) %>% 
  mutate(tot_n_cps_accros_dest = sum(n_cps_adj_)) %>% 
  ungroup() %>%
  mutate(rel = n_cps_adj_/tot_n_cps_accros_dest) %>% # migration (out) share in 1999
  distinct(state_dest, state_ori, sector_dest, sector_ori, .keep_all = TRUE) %>% 
  select(year, state_dest, state_ori, sector_dest, sector_ori, rel) %>%
  arrange(year, state_ori, sector_ori, state_dest, sector_dest)
write_xlsx(mu_1999, path = paste("1-Intermediate_Processed_Data/mu_1999_long_format.xlsx", sep=""))
mu_1999 <- mu_1999 %>%
  mutate(sector_dest = recode(as.character(sector_dest), '0' ="00", '1' ="01", '2' ="02", '3' ="03", '4' ="04", '5' ="05", '6' ="06", '7' ="07", '8' ="08", '9' ="09" )) %>%
  mutate(state_dest_sector_dest = paste(state_dest, sector_dest, sep="_")) %>%
  select(-state_dest, -sector_dest)
mu_1999 <- spread(mu_1999, state_dest_sector_dest, rel, fill = NA, convert = TRUE,  drop = TRUE, sep = NULL)

# check sum(prob)==1
epsilon <- 0.01
check <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
if(sum(abs(as.matrix(rowSums(check)) - matrix(1, dim(check)[1], 1))) > epsilon) 
  stop("mobility shares do not add to 1")
# write_xlsx(mu_1999, path = paste("2-Final_Data/mu_1999.xlsx", sep=""))

# check L_1999 and mu_1999 gives L_2000
L_2000 <- read.csv(paste("1-Intermediate_Processed_Data/L_2000.csv", sep=""), header = TRUE, sep = ",", dec = ".")
L_2000 <- melt(L_2000, id.vars=c("state"), variable.name="sector", value.name = "employ")
L_2000 <- L_2000 %>% 
  mutate(sector = as.numeric(gsub("X", "", sector))) %>%
  arrange(state, sector)
L_2000 <- as.matrix(L_2000$employ)
L_1999 <- as.matrix(temp_L_1999$employ)
mu_1999 <- mu_1999 %>% select(-year, -state_ori, -sector_ori)
mu_1999 <- as.matrix(mu_1999)
if(sum(L_2000 - (t(mu_1999)%*%L_1999)) > epsilon) 
  stop(paste("L_1999 and mu_1999 do NOT give L_2000"))

```
For each state
1. Average of the diagonals: within state within sector; Max min median of the diagonals 

2. Probability stay-in state (within state migration): the probability that they stay in the same state (any sector)

3. Probability stay-in sector (within same sector migration): the probability that they stay in the same sector (regardless maybe state change)

4. Transition probability

For all state
Histogram of all diagonals across all states

To benchmark the transition probability from annual migration matrix to the literature:
The numbers are consistent with the estimates by Molloy, Smith, and Wozniak (2011) for annual interstate moves and Kambourov and Manovskii (2008) for intersectoral mobility.


```{r}
# average for migration share within same state within same sector
mu_1999_0  <- read_xlsx(path = paste("1-Intermediate_Processed_Data/mu_1999_0_long_format.xlsx", sep=""))
mu_1999_1  <- read_xlsx(path = paste("1-Intermediate_Processed_Data/mu_1999_long_format.xlsx", sep=""))
mu_1999_2  <- read_xlsx(path = paste("1-Intermediate_Processed_Data/mu_1999_irs_4_long_format.xlsx", sep=""))

average_diag_0  <- mu_1999_0  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  group_by(state_ori)   %>%
  summarise(mean_diag_0 = mean(rel), max_diag_0 = max(rel), min_diag_0 = min(rel), p25_diag_0 = quantile(rel, 0.25), p50_diag_0 = quantile(rel, 0.5), p75_diag_0 = quantile(rel, 0.75))  %>% 
  ungroup()

average_diag_1  <- mu_1999_1  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  group_by(state_ori)   %>%
  summarise(mean_diag_1 = mean(rel), max_diag_1 = max(rel), min_diag_1 = min(rel), p25_diag_1 = quantile(rel, 0.25), p50_diag_1 = quantile(rel, 0.5), p75_diag_1 = quantile(rel, 0.75))  %>% 
  ungroup()

average_diag_2  <- mu_1999_2  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  group_by(state_ori)   %>%
  summarise(mean_diag_2 = mean(rel), max_diag_2 = max(rel), min_diag_2 = min(rel), p25_diag_2 = quantile(rel, 0.25), p50_diag_2 = quantile(rel, 0.5), p75_diag_2 = quantile(rel, 0.75))  %>% 
  ungroup()

average_diag  <- average_diag_1  %>% 
  left_join(average_diag_2, by = c('state_ori' = 'state_ori')) %>% 
  left_join(average_diag_0, by = c('state_ori' = 'state_ori')) %>% 
  select(state_ori, mean_diag_0, mean_diag_1, mean_diag_2, max_diag_0, max_diag_1, max_diag_2, min_diag_0, min_diag_1, min_diag_2, p25_diag_0, p25_diag_1, p25_diag_2, p50_diag_0, p50_diag_1, p50_diag_2, p75_diag_0, p75_diag_1, p75_diag_2)

# Probability stay-in same state
migration_1999_0  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_0.csv", sep=""), header = TRUE, sep = ",", dec = ".")
migration_1999_1  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime.csv", sep=""), header = TRUE, sep = ",", dec = ".")
migration_1999_2  <- read.csv(file = paste("1-Intermediate_Processed_Data/mu_1999_prime_irs_4.csv", sep=""), header = TRUE, sep = ",", dec = ".")

prob_same_state_0  <- migration_1999_0 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest]))  %>% 
  ungroup()  %>% 
  mutate(stay_in_state_share_0 = stay_in_num/l_1999)  %>% 
  select(state_ori, stay_in_state_share_0)  %>% 
  distinct(state_ori, stay_in_state_share_0, .keep_all = TRUE)

prob_same_state_1  <- migration_1999_1 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest]))  %>% 
  ungroup()  %>% 
  mutate(stay_in_state_share_1 = stay_in_num/l_1999)  %>% 
  select(state_ori, stay_in_state_share_1)  %>% 
  distinct(state_ori, stay_in_state_share_1, .keep_all = TRUE)

prob_same_state_2  <- migration_1999_2 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest]))  %>% 
  ungroup()  %>% 
  mutate(stay_in_state_share_2 = stay_in_num/l_1999)  %>% 
  select(state_ori, stay_in_state_share_2)  %>% 
  distinct(state_ori, stay_in_state_share_2, .keep_all = TRUE)
           
prob_same_state  <- prob_same_state_1  %>% 
  left_join(prob_same_state_2, by = c('state_ori' = 'state_ori')) %>% 
  left_join(prob_same_state_0, by = c('state_ori' = 'state_ori')) 
         
# Probability stay-in same sector
prob_same_sector_0  <- migration_1999_0 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(stay_in_sector_share_0 = stay_in_num/l_1999)  %>% 
  select(state_ori, stay_in_sector_share_0)  %>% 
  distinct(state_ori, stay_in_sector_share_0, .keep_all = TRUE)

prob_same_sector_1  <- migration_1999_1 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(stay_in_sector_share_1 = stay_in_num/l_1999)  %>% 
  select(state_ori, stay_in_sector_share_1)  %>% 
  distinct(state_ori, stay_in_sector_share_1, .keep_all = TRUE)

prob_same_sector_2  <- migration_1999_2 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(stay_in_sector_share_2 = stay_in_num/l_1999)  %>% 
  select(state_ori, stay_in_sector_share_2)  %>% 
  distinct(state_ori, stay_in_sector_share_2, .keep_all = TRUE)

prob_same_sector  <- prob_same_sector_1  %>% 
  left_join(prob_same_sector_2, by = c('state_ori' = 'state_ori')) %>% 
  left_join(prob_same_sector_0, by = c('state_ori' = 'state_ori')) 


# Transition probability
prob_same_state_sector_0  <- migration_1999_0 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(same_state_sector_0 = stay_in_num/l_1999)  %>% 
  select(state_ori, same_state_sector_0)  %>% 
  distinct(state_ori, same_state_sector_0, .keep_all = TRUE)

prob_same_state_sector_1  <- migration_1999_1 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(same_state_sector_1 = stay_in_num/l_1999)  %>% 
  select(state_ori, same_state_sector_1)  %>% 
  distinct(state_ori, same_state_sector_1, .keep_all = TRUE)

prob_same_state_sector_2  <- migration_1999_2 %>% 
  group_by(year, state_ori)  %>% 
  mutate(l_1999 = sum(level_employ))  %>% 
  mutate(stay_in_num = sum(level_employ[state_ori == state_dest & sector_ori == sector_dest]))  %>% 
  ungroup()  %>% 
  mutate(same_state_sector_2 = stay_in_num/l_1999)  %>% 
  select(state_ori, same_state_sector_2)  %>% 
  distinct(state_ori, same_state_sector_2, .keep_all = TRUE)

transition_prob  <- prob_same_state_sector_1  %>% 
  left_join(prob_same_state_sector_2, by = c('state_ori' = 'state_ori'))  %>% 
  left_join(prob_same_state_sector_0, by = c('state_ori' = 'state_ori')) 

transition_prob  <- transition_prob  %>% 
  left_join(prob_same_sector, by = c('state_ori' = 'state_ori'))  

transition_prob  <- transition_prob  %>% 
  left_join(prob_same_state, by = c('state_ori' = 'state_ori'))  

transition_prob  <- transition_prob  %>% 
  mutate(same_state_diff_sector_0 = stay_in_state_share_0 - same_state_sector_0)  %>% 
  mutate(same_state_diff_sector_1 = stay_in_state_share_1 - same_state_sector_1)  %>% 
  mutate(same_state_diff_sector_2 = stay_in_state_share_2 - same_state_sector_2)  %>% 
  mutate(diff_state_same_sector_0 = stay_in_sector_share_0 - same_state_sector_0)  %>% 
  mutate(diff_state_same_sector_1 = stay_in_sector_share_1 - same_state_sector_1)  %>% 
  mutate(diff_state_same_sector_2 = stay_in_sector_share_2 - same_state_sector_2)  %>% 
  select(state_ori, same_state_sector_0, same_state_sector_1, same_state_sector_2, stay_in_sector_share_0, stay_in_sector_share_1, stay_in_sector_share_2, stay_in_state_share_0, stay_in_state_share_1, stay_in_state_share_2, same_state_diff_sector_0, same_state_diff_sector_1, same_state_diff_sector_2, diff_state_same_sector_0, diff_state_same_sector_1, diff_state_same_sector_2)


# Histogram
mu_1999_1  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  ggplot() +
  geom_histogram(aes(x = rel))

mu_1999_1  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  ggplot() +
  geom_histogram(aes(x = rel, y = after_stat(count) / sum(after_stat(count))))

mu_1999_1  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  ggplot() +
  geom_density(aes(x = rel))
  
mu_1999_2  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  ggplot() +
  geom_histogram(aes(x = rel))

mu_1999_2  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  ggplot() +
  geom_histogram(aes(x = rel, y = after_stat(count) / sum(after_stat(count))))

mu_1999_2  %>% 
  filter(state_ori == state_dest & sector_ori == sector_dest)  %>% 
  ggplot() +
  geom_density(aes(x = rel))


```







































