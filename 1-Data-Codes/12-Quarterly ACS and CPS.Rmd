---
title: "Quarterly ACS and CPS"
author: "Yuanhang(Leo) Yu"
date: "2023-05-26"
output:
  html_document:
    toc: yes
    df_print: paged
  # pdf_document:
    # number_sections: yes
  # html_notebook:
    # toc: yes
    # df_print: paged
    # number_sections: yes
header-includes:
- \usepackage{amsmath}
- \usepackage{amssymb}
- \usepackage{pifont}
- \usepackage{mathpazo}
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
remove(list = ls())  
```


```{r message=FALSE, warning=FALSE, cache=FALSE, include=FALSE, results='hide'}
# Define function
`%notin%` <- Negate(`%in%`)
# libraries
options( scipen=100, digits = 15, stringsAsFactors=FALSE ); # no scientific notation, up to 15 digits 
# vector of libraries to be used
libs <- c( 'dplyr', 'tidyr', 'haven', 'stringr', 'nleqslv', 'gdata', 'formattable', 'ggplot2', 'viridis', 'RColorBrewer', 'reshape2', 'foreign', 'readxl', 'writexl', 'rjson', 'read_excel', 'Matrix', 'geodist', 'readr', 'data.table', 'stringr', 'haven');
# Install libraries in case they are not installed
for( i in seq_along(libs)){ 
    if( !(libs[i] %in% installed.packages()) ) install.packages( libs[i] ) 
};
# Loading libraries
lapply( libs, require, character.only=TRUE );
```

```{r additional data}
# region: US states and other countries
regions <- read.csv("0-Raw_Data/regions.csv")  
c_names <- regions %>% filter(status == "country")
c_names <- c_names$region

s_names <- regions %>% filter(status == "state") 
s_names <- s_names$region

# sector reclassification table (NAICS to final)
sectors_naics_final <- read.csv(paste("0-Raw_Data/sectors.csv", sep=""), header = TRUE, sep = ",", dec = ".")
sectors_naics_final <- sectors_naics_final %>% 
  select(final_sector, naics) %>%
  mutate(naics = as.character(naics)) %>%
  distinct(final_sector, naics)     #create the mapping table from NAICS to final at sector level

# sectors (CENSUS 1990 to final)
sectors_census1990_final <- read.csv(paste("0-Raw_Data/sectors_census_1990.csv", sep=""), header = TRUE, sep = ",", dec = ".")
sectors_census1990_final <- sectors_census1990_final %>%
  filter(is.na(final_sector) == FALSE) %>%
  mutate(census_1990 = as.character(census_1990)) %>%
  select(census_1990, final_sector)

# sectors (CENSUS 2003 to naics)
sectors_census2003_naics <- read.csv(paste("0-Raw_Data/sectors_census_2003.csv", sep=""), header = TRUE, sep = ",", dec = ".")
sectors_census2003_naics <- sectors_census2003_naics %>%
  mutate(naics = as.character(naics)) %>%
  distinct(census_2003, .keep_all = TRUE)

# sectors (CENSUS 2003 to final)
sectors_census2003_final <- sectors_census2003_naics %>%
  left_join(sectors_naics_final, by=c('naics'='naics')) %>% #NAICS to final sector
  filter(is.na(final_sector) == FALSE) %>%
  mutate(census_2003 = as.character(census_2003)) %>%
  select(census_2003, final_sector)

# state codes
states_fips <- read_excel("0-Raw_Data/Fips/states_fips_num.xlsx", range = "A1:D53")
states_fips_mod_ACS <- states_fips %>% 
  select(st_num, st_name) %>%
  mutate(st_num = ifelse(st_num > 8, st_num + 1, st_num)) %>%
  distinct(st_name, .keep_all = TRUE) %>%
  dplyr::rename(st_name1 = st_name)  #state code that is consistent with used in ACS
states_fips <- states_fips %>% select(st_fips, st_num, st_name)

```

## Quarterly migration matrix with IRS data

### Generate quarterly ACS migration data
```{r message = FALSE}
yr_list <- c("00", "01", "02", "03", "04", "05", "06", "07")
st_list <- c("al", "ak", "az", "ar", "ca", "co", "ct", "de", "fl", "ga", "hi", "id", "il", "in", "ia", "ks", "ky", "la", "me", "md", "ma", "mi", "mn", "ms", "mo", "mt", "ne", "nv", "nh", "nj", "nm", "ny", "nc", "nd", "oh", "ok", "or", "pa", "ri", "sc", "sd", "tn", "tx", "ut", "vt", "va", "wa", "wv", "wi", "wy")

# loading PUMS ACS
acs_final_base  <- c()
yr_c <- 2000 # controls the year
for (yr in yr_list) { 
  acs <- c() 
  c <- 1 # controls the destination state
for (st in st_list) { # loop over all the original states
  if (yr_c == 2000){ACS_PUMS <- read_csv(paste("0-Raw_Data/ACS/20", yr,"/c2ssp", st,".csv", sep=""))}  
  if (yr_c != 2000){ACS_PUMS <- read_csv(paste("0-Raw_Data/ACS/20", yr,"/ss", yr,"p", st,".csv", sep=""))}    
  ACS_PUMS$year <- yr_c
  ACS_PUMS <- ACS_PUMS %>%  # ACS: inter/intra-state flows but without knowing the sector of origin
    select(year, AGEP, POWSP, MIGSP, ESR, NAICSP, PWGTP) %>%
    mutate(AGEP = as.numeric(AGEP),
           POWSP = as.numeric(POWSP),
           MIGSP = as.numeric(MIGSP),
           ESR = as.numeric(ESR), 
           PWGTP = as.numeric(PWGTP)) %>%
    filter( is.na(AGEP) == TRUE  | (AGEP >= 25 & AGEP <=65)) %>% # age
    filter( is.na(ESR) == FALSE & (ESR==1 |ESR==2 | ESR==3 | ESR==6)) %>% # employ status
    mutate(ESR = as.numeric( recode( as.character(ESR), '6' ="0", '3' ="0", '1' = "1", '2' = "1"))) %>%
    filter( is.na(POWSP) == TRUE | (is.na(POWSP) == FALSE & POWSP != 11 & POWSP <= 56 & year>=2003) | (is.na(POWSP) == FALSE & POWSP != 9 & POWSP <= 51 & year<=2002)) %>%
    left_join(states_fips, by=c('POWSP' = 'st_fips')) %>% 
    mutate(st_num = ifelse(year <= 2002, POWSP, st_num)) %>%
    mutate(st_num = ifelse(year <= 2002 & POWSP > 8, st_num - 1, st_num)) %>%       
    filter( is.na(st_num) == TRUE  | (is.na(st_num) == FALSE & st_num == c)) %>% # workplace (state)
    select(-st_name, -POWSP, -st_num) %>%
    mutate(state_dest = s_names[c]) %>% 
    filter( is.na(MIGSP) == TRUE | (is.na(MIGSP) == FALSE & MIGSP != 11 & MIGSP <= 56 & year>=2003) | (is.na(MIGSP) == FALSE & MIGSP != 9 & MIGSP <= 51 & year<=2002)) %>%
    left_join(states_fips, by = c('MIGSP' = 'st_fips')) %>% # lived 1 yr ago
    left_join(states_fips_mod_ACS, by = c('MIGSP' = 'st_num')) %>% # lived 1 yr ago
    mutate(st_name = ifelse(year <= 2002, st_name1, st_name)) %>%
    select(-MIGSP, -st_num, -AGEP, -st_name1) %>%
    dplyr::rename(state_ori = st_name, employ_status = ESR) %>%
    mutate(state_ori = ifelse(is.na(state_ori) == TRUE, s_names[c], state_ori)) %>% # no MIG
    dplyr::rename(naics = NAICSP) %>%
    mutate(naics = substr(naics, start=1, stop=3)) %>%
    mutate(naics = ifelse(employ_status == 0, NA, naics)) %>%
    filter((employ_status == 0 & is.na(naics) == TRUE)|(employ_status == 1 & is.na(naics) == FALSE)) %>%
    mutate(naics = ifelse(naics == "23", "230", naics)) %>%
    mutate(naics = ifelse(naics == "31M", "313", naics)) %>%
    mutate(naics = ifelse(naics == "4MS", "423", naics)) %>%
    left_join(sectors_naics_final, by=c('naics'='naics')) %>% #NAICS to final sector
    dplyr::rename(sector_dest = final_sector) %>%
    filter(is.na(sector_dest) == FALSE) %>%
    select(-naics, -employ_status)  # ACS_PUMS: year, state_dest, state_ori, sector_dest, PWGTP (at surveyed representative individual level)
  
  acs <- bind_rows(acs, ACS_PUMS)
  c <- c + 1
}

  state_list  <- unique(acs$state_ori)
  mover_q1  <- c()
  mover_q2  <- c()
  mover_q3  <- c()
  mover_q4  <- c()
  
  for (st in state_list) {
    temp  <- acs  %>% 
      filter(state_ori == st)
    set.seed(999)
    mover  <- temp  %>% 
      filter(state_dest != state_ori) 
    num_obs  <- nrow(mover)
    mover  <- mover  %>% 
      mutate(random_num = runif(num_obs))  %>% 
      mutate(flag = ifelse(random_num <= quantile(random_num, 0.25), 1, 0))  %>% 
      mutate(flag = ifelse(random_num > quantile(random_num, 0.25) & random_num <= quantile(random_num, 0.5), 2, flag))  %>%
      mutate(flag = ifelse(random_num > quantile(random_num, 0.5) & random_num <= quantile(random_num, 0.75), 3, flag))  %>%
      mutate(flag = ifelse(random_num > quantile(random_num, 0.75), 4, flag))
    
    mover_q1_temp  <- mover  %>% 
      mutate(state_dest = ifelse(flag != 1, state_ori, state_dest)) 
    mover_q1  <- bind_rows(mover_q1, mover_q1_temp)
    
    mover_q2_temp  <- mover  %>% 
      mutate(state_dest = ifelse(flag != 2, state_ori, state_dest))
    mover_q2  <- bind_rows(mover_q2, mover_q2_temp)
    
    mover_q3_temp  <- mover  %>% 
      mutate(state_dest = ifelse(flag != 3, state_ori, state_dest))
    mover_q3  <- bind_rows(mover_q3, mover_q3_temp)
    
    mover_q4_temp  <- mover  %>% 
      mutate(state_dest = ifelse(flag != 4, state_ori, state_dest))
    mover_q4  <- bind_rows(mover_q4, mover_q4_temp)
  
  }

  acs_q1  <- acs  %>% 
    filter(state_dest == state_ori)  %>% 
    bind_rows(mover_q1)
  acs_q2  <- acs  %>% 
    filter(state_dest == state_ori)  %>% 
    bind_rows(mover_q2)
  acs_q3  <- acs  %>% 
    filter(state_dest == state_ori)  %>% 
    bind_rows(mover_q3)
  acs_q4  <- acs  %>% 
    filter(state_dest == state_ori)  %>% 
    bind_rows(mover_q4)

  # counting by state and sector, origin and destination
  acs_q1 <- acs_q1 %>%
    group_by(year, sector_dest, state_dest, state_ori) %>%
    mutate(n = sum(PWGTP)) %>% # weights (how many the obs represents, many surveyed representative obs within the same migration combination)
    ungroup() %>%
    distinct(year, sector_dest, state_dest, state_ori, .keep_all = TRUE) %>%  #keep one migration combination
    select(-PWGTP, -random_num) #there are many missing migration combinations
  acs_q2 <- acs_q2 %>%
    group_by(year, sector_dest, state_dest, state_ori) %>%
    mutate(n = sum(PWGTP)) %>% # weights (how many the obs represents, many surveyed representative obs within the same migration combination)
    ungroup() %>%
    distinct(year, sector_dest, state_dest, state_ori, .keep_all = TRUE) %>%  #keep one migration combination
    select(-PWGTP, -random_num) #there are many missing migration combinations 
  acs_q3 <- acs_q3 %>%
    group_by(year, sector_dest, state_dest, state_ori) %>%
    mutate(n = sum(PWGTP)) %>% # weights (how many the obs represents, many surveyed representative obs within the same migration combination)
    ungroup() %>%
    distinct(year, sector_dest, state_dest, state_ori, .keep_all = TRUE) %>%  #keep one migration combination
    select(-PWGTP, -random_num) #there are many missing migration combinations  
  acs_q4 <- acs_q4 %>%
    group_by(year, sector_dest, state_dest, state_ori) %>%
    mutate(n = sum(PWGTP)) %>% # weights (how many the obs represents, many surveyed representative obs within the same migration combination)
    ungroup() %>%
    distinct(year, sector_dest, state_dest, state_ori, .keep_all = TRUE) %>%  #keep one migration combination
    select(-PWGTP, -random_num) # there are many missing migration combinations  
  
  # adding missing combinations (sector_dest, state_dest, state_ori)
  temp <- data.frame(s_names)  
  sec  <- c(0:14)
  temp_sec  <- data.frame(sec)
  combo_st_sec  <- expand.grid(state_ori = temp$s_names, state_dest = temp$s_names, sector_dest = temp_sec$sec) 
  acs_q1  <- combo_st_sec  %>% 
    left_join(acs_q1, by=c('state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest'))  %>% 
    mutate(year = yr_c - 1)  %>% 
    mutate(quarter = 1)  %>% 
    mutate(n = ifelse(is.na(n), 0, n))  %>% 
    select(-flag) 
  acs_q2  <- combo_st_sec  %>% 
    left_join(acs_q2, by=c('state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest'))  %>% 
    mutate(year = yr_c - 1)  %>% 
    mutate(quarter = 2)  %>% 
    mutate(n = ifelse(is.na(n), 0, n))  %>% 
    select(-flag)
  acs_q3  <- combo_st_sec  %>% 
    left_join(acs_q3, by=c('state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest'))  %>% 
    mutate(year = yr_c - 1)  %>% 
    mutate(quarter = 3)  %>% 
    mutate(n = ifelse(is.na(n), 0, n))  %>% 
    select(-flag)
  acs_q4  <- combo_st_sec  %>% 
    left_join(acs_q4, by=c('state_dest' = 'state_dest', 'state_ori' = 'state_ori', 'sector_dest' = 'sector_dest'))  %>% 
    mutate(year = yr_c - 1)  %>% 
    mutate(quarter = 4)  %>% 
    mutate(n = ifelse(is.na(n), 0, n))  %>% 
    select(-flag)
  
  add  <- acs_q1  %>% 
    bind_rows(acs_q2)  %>% 
    bind_rows(acs_q3)  %>% 
    bind_rows(acs_q4) 
  
  acs_final_base  <- bind_rows(acs_final_base, add)
  
  yr_c  <-  yr_c + 1
}

# rolling basis: three-year window
final_base <- c()
for (yr in 1999:2006){
for (q in 1:4) {
temp <- acs_final_base %>%
  filter( (year == yr & quarter >= q) | (year == yr + 1 ) | (year == yr + 2 & quarter <= q-1 ) ) %>%
  mutate(year = yr)  %>%   # now under yr, it actually contains three years obs
  mutate(quarter = q)
final_base <- rbind(final_base, temp) 
}
}

#counting by state and sector, origin and destination on three-year rolling basis
acs_final <- final_base %>%
  group_by(year, quarter, sector_dest, state_dest, state_ori) %>%
  mutate(n_acs = sum(n)) %>%  
  ungroup() %>%
  distinct(year, quarter, sector_dest, state_dest, state_ori, .keep_all = TRUE)

#Some checks and adjustment (all based on three-year window)
##a. use average total migration flow across years to fill in the missing within state migration
acs_final <- acs_final %>%
  mutate(diag = ifelse(state_ori == state_dest, 1, 0)) %>%
  group_by(state_ori, state_dest, sector_dest) %>%
  mutate(n_acs_mean = mean(n_acs)) %>% #average total migration flow across years 
  ungroup() %>%
  mutate(n_acs = ifelse(diag == 1 & n_acs == 0, n_acs_mean, n_acs)) %>% #use n_acs_mean to fill in the missing within state migration: Alaska(1999,2006), NewMexico(1999,2000), Hawaii(2006)
  select(-n_acs_mean, -diag)
##b. given (year, state_ori, sector_dest), the within state_ori migration to that destination sector should be greater than any across state migration from that state_ori to that sector_dest; otherwise, replace it with average across destination states
acs_final <- acs_final %>%
  mutate(n_acs_temp = ifelse(state_ori==state_dest, n_acs, 0)) %>% #n_acs_temp: within state migration across sector (three-year window), others 0
  group_by(year, quarter, state_ori, sector_dest) %>%
  mutate(n_acs_temp = max(n_acs_temp), mean_n_acs = mean(n_acs)) %>% #n_acs_temp: either equals to within state_ori migration or zero ; mean_n_acs: average flows from (year, state_ori, sector_dest) pair to any other state
  ungroup() %>%
  mutate(n_acs = ifelse(n_acs_temp<n_acs, mean_n_acs, n_acs)) %>% #condition: for any (year, state_ori, state_dest, sector_dest), if the within state migration for one sector is less than the migration for this combination,  replace with the average n_acs from (year, state_ori, sector_dest). Potential concern: given (year, state_ori, sector_dest), the within state migration flow to that sector should be greater than the across state migration, if it is less, replace it with average migration flow to that sector across states. Total 22 cases.
  select(-n_acs_temp, -mean_n_acs)
##c. given (year, state_dest, sector_dest), the within state_dest migration to that destination sector should be greater than the any across state migration to that state_dest and to that sector_dest
acs_final <- acs_final %>%
  mutate(n_acs_temp = ifelse(state_ori==state_dest, n_acs, 0)) %>% #n_acs_temp: within state migration across sector, others 0
  group_by(year, quarter, state_dest, sector_dest) %>%
  mutate(n_acs_temp = max(n_acs_temp),mean_n_acs = mean(n_acs)) %>% #n_acs_temp: either equals to within state_dest migration or zero; mean_n_acs: average flows to (year, state_dest, sector_dest) pair from any other state
  ungroup() %>%
  mutate(n_acs = ifelse(n_acs_temp<n_acs, mean_n_acs, n_acs)) %>% #Potential concern: given (year, state_dest, sector_dest), the within state_dest migration flow to that sector should greater than the across state migration, if it is less, replace it with average migration flow to that sector across original states.  Total 2 cases.
  select(-n_acs_temp, -mean_n_acs)

write.table(acs_final, file = paste("1-Intermediate_Processed_Data/acs_quarterly.csv", sep=""), sep = ",", row.names = FALSE)

```

### Generate quarterly CPS migration data
```{r message=FALSE, warning=FALSE}
# CPS: sector-sector within state movements
mn_list <- c("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec")
yr_list <- c("98","99", "00", "01", "02", "03", "04", "05", "06", "07", "08")

# loading PUMS CPS
cps_list <- vector("list", length = length(mn_list)*length(yr_list))
p <- 1
for (yr in yr_list){
print(yr)
for (mn in mn_list){
CPS_PUMS <- read_csv(paste("0-Raw_Data/CPS/", mn, yr,"pub_.txt", sep=""), col_names = FALSE)
CPS_PUMS$year <- yr
CPS_PUMS$month <- mn

# solving H_ID variable changes around 2004
list_bef_may <- c("jan", "feb", "mar", "apr")
list_aft_may <- c("may", "jun", "jul", "aug", "sep", "oct", "nov", "dec")

# creating variables: year, person id, employment status, sector info.....
CPS_PUMS <- CPS_PUMS %>%
  mutate(year = as.numeric(year)) %>%
  mutate(year = ifelse( (year!=99 & year!=98 & year!=97), 2000 + year, 1900+year)) %>%
  mutate(len = nchar(X1)) %>% #len matches data dictionary
  mutate(person_weight_1 = as.numeric(substr(X1, start=846, stop=855))) %>% #weight final
  mutate(person_weight_2 = as.numeric(substr(X1, start=593, stop=602))) %>% #weight longitude
  mutate(inter_num = as.numeric(substr(X1, start=63, stop=64))) %>% #interview number (1-8)
  mutate(H_ID_1 = substr(X1, start=1, stop=15)) %>% #household ID 
  mutate(H_ID_2 = substr(X1, start=71, stop=74)) %>% 
  mutate(H_ID_3 = substr(X1, start=75, stop=76)) %>%
  mutate(H_ID_4 = substr(X1, start=77, stop=78)) %>% #sample house replacement  
  mutate(H_ID = paste(H_ID_1, H_ID_2, H_ID_3, H_ID_4, sep="_")) %>%
  select(-H_ID_2, -H_ID_3, -H_ID_4) %>%
  mutate(temp = ifelse( ((inter_num<=4 & year == 2003) | (inter_num>=5 & year == 2004)) & month %in% list_aft_may, 1, 0)) %>% # households with H_ID issue
  mutate(temp = ifelse( ((inter_num<=4 & year == 2004) | (inter_num>=5 & year == 2005)) & month %in% list_bef_may, 1, temp)) %>% # households with H_ID issue
  mutate(H_ID_2_bef = substr(X1, start=72, stop=73)) %>% 
  mutate(H_ID_2_aft = substr(X1, start=71, stop=72)) %>% 
  mutate(H_ID = ifelse(temp==1 & inter_num<=4, paste(H_ID_1, H_ID_2_bef, sep="_"), H_ID)) %>%
  mutate(H_ID = ifelse(temp==1 & inter_num>=5, paste(H_ID_1, H_ID_2_aft, sep="_"), H_ID)) %>%
  select(-H_ID_1, -H_ID_2_bef, -H_ID_2_aft) %>%
  mutate(age = as.numeric(substr(X1, start=122, stop=123))) %>% #age
  filter(age >=25 & age <=65) %>%
  mutate(gender = as.numeric(substr(X1, start=129, stop=130))) %>% #male: 1; female: 2
  arrange(year, month, H_ID, -age) %>%
  group_by(year, month, H_ID) %>%
  mutate(P_ID = 1:n()) %>%
  ungroup() %>%
  mutate(employ_status = as.numeric(substr(X1, start=180, stop=181))) %>% #employ status
  filter( is.na(employ_status)==FALSE & ((employ_status>=1 & employ_status<=6)|employ_status==7)) %>%
  mutate(employ_status = as.numeric( recode( as.character(employ_status), '6' ="0", '5' ="0", '7' ="0", '4' ="0", '3' ="0", '2' = "1", '1' = "1"))) %>%
  mutate(st_fips = as.numeric(substr(X1, start=93, stop=94))) %>% #state
  filter( is.na(st_fips) == FALSE & (st_fips != 11 & st_fips <= 56)) %>%
  left_join(states_fips, by=c('st_fips' = 'st_fips')) %>% 
  select(-st_fips) %>%
  mutate(census_sec = ifelse( year < 2003, substr(X1, start = 436, stop = 438), substr(X1, start = 856, stop=858))) %>% #census_sec bef and aft 2003
  mutate(census_sec = ifelse(employ_status == 0, NA, census_sec)) %>%
  filter((employ_status == 0 & is.na(census_sec) == TRUE)|(employ_status == 1 & is.na(census_sec) == FALSE)) %>%
  mutate(census_sec = gsub(" ", "", census_sec)) %>%
  select(-X1)

cps_list[[p]] <- CPS_PUMS
rm(CPS_PUMS)
print(paste0(yr, ",", mn))

p <- p + 1
}  
}
cps <- rbindlist(cps_list)
cps <- cps %>%
  arrange(year, month, H_ID, -age)
rm(cps_list)

# sectors: map census_sec to final sector 
cps_1 <- cps %>%
  filter(year < 2003) %>%
  left_join(sectors_census1990_final, by=c('census_sec'='census_1990')) %>% #census_sec to final sector
  dplyr::rename(sector = final_sector) %>%
  filter(is.na(sector) == FALSE) %>%
  select(-census_sec, -len, -employ_status, -st_num, -temp)

  
cps_2 <- cps %>%
  filter(year >= 2003) %>%
  left_join(sectors_census2003_final, by=c('census_sec'='census_2003')) %>% #census_sec to final sector
  dplyr::rename(sector = final_sector) %>%
  filter(is.na(sector) == FALSE) %>%
  select(-census_sec, -len, -employ_status, -st_num, -temp)

cps <- rbind(cps_1, cps_2)
rm(cps_1, cps_2)

write.table(cps, file = paste("1-Intermediate_Processed_Data/cps_1_quarterly.csv", sep=""), sep = ",", row.names = FALSE) # cps data: individual employment and state status with household ID each month from 1998-2008

cps <- read.csv(paste("1-Intermediate_Processed_Data/cps_1_quarterly.csv", sep=""), header = TRUE, sep = ",", dec = ".")

mn_list <- c("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec")

quart_inter  <- c(1 , 4, 5, 8)

# annual matching
a  <- cps  %>% 
  distinct(H_ID, P_ID)  %>% 
  n_distinct()
# changes for quarterly matrix: match for interview 1&4, 5&8
## keep two observations
cps  <- cps  %>% 
  arrange(H_ID, P_ID, inter_num)

cps  <- cps  %>% 
  group_by(H_ID, P_ID)  %>% 
  filter(inter_num  %in% quart_inter)  %>% 
  filter(
    (all(c(1, 4) %in% inter_num)) |
    (all(c(5, 8) %in% inter_num))
  )  %>% 
  ungroup()

## keep only one observation
#cps <- cps %>%
#  group_by(H_ID, P_ID) %>%
#  filter(any(inter_num == 4) & any(inter_num == 1))  %>% 
#  ungroup()
c <- cps  %>% 
  distinct(H_ID, P_ID)  %>% 
  n_distinct()
# household matching rate
print(c*100/(a))  # 72% 


# matching persons via same month in consecutive years based on H_ID and P_ID
base <- c()
for (yr in 1999:2008) {
temp_cps  <- cps  %>% 
    filter(year == yr | year == yr - 1)  
a <- dim(temp_cps)[1]
temp_cps <- temp_cps %>%
  group_by(H_ID, P_ID, month) %>%  # within the same month (over a year)
  filter( abs(max(age)-min(age)) <= 1  & max(gender) == min(gender)) %>%
  ungroup()
b <- dim(temp_cps)[1]
# person matching rate
print(b*100/a)

info_present  <- temp_cps  %>% 
  group_by(H_ID, P_ID, year)  %>%    # there will be double accounting issues (when 1&4 and 5&8 are both present)
  filter(inter_num == 4 | inter_num == 8)  %>% 
  ungroup()  %>% 
  select(-year, -month)  %>% # using the person weight at the destination wave, because when calculate labour distribution this project uses backward calculation, i.e given L_2000 using migration share in 1999 to back out the L_1999
  dplyr::rename(sector_dest = sector, state_dest = st_name)

info_past  <- temp_cps  %>% 
  group_by(H_ID, P_ID, year)  %>% 
  filter(inter_num == 1 | inter_num == 5)  %>% 
  ungroup()  %>% 
  select(-age, -gender, -person_weight_1, -person_weight_2) %>%
  dplyr::rename(sector_ori = sector, state_ori = st_name)
  
temp <- full_join(info_present, info_past, by = c("H_ID", "P_ID"))  %>% # after matching, get state info for t and t-1 from CPS
  filter( inter_num.x - inter_num.y == 3 )  # %>% select(-inter_num.x, -inter_num.y)

temp <- temp %>%
  filter(is.na(state_ori) == FALSE & is.na(state_dest) == FALSE) %>% # only matches
  distinct(H_ID, P_ID, year, month, .keep_all = TRUE)

base <- rbind(base, temp)

}
#base  <- base  %>% 
#  arrange(H_ID, P_ID, inter_num.x)

base  <- base  %>% 
  distinct(year, month, H_ID, P_ID, .keep_all = TRUE)

#base  <- base  %>%
#  group_by(year, month, H_ID, P_ID) %>%  
#  mutate(n = n())
# 
#base  <- base  %>% 
#  arrange(year, month, H_ID, P_ID)


base  <- base  %>% 
  mutate(quarter = ifelse(month %in% c("jan", "feb", "mar"), 1, 0) )  %>% 
  mutate(quarter = ifelse(month %in% c("apr", "may", "jun"), 2, quarter ))  %>% 
  mutate(quarter = ifelse(month %in% c("jul", "aug", "sep"), 3, quarter ))  %>% 
  mutate(quarter = ifelse(month %in% c("oct", "nov", "dec"), 4, quarter ))  

before_rolling  <- base  %>% 
  mutate(year = year - 1)

# rolling basis: 5-year window
final_base <- c()
for (yr in 2000:2007) {
for (q in 1:4) {
  temp <- base %>%
    #filter((year == yr-2 & quarter >= q) | (year >= yr - 1 & year <= yr + 1 ) | (year == yr + 2 & quarter <= q-1 )) %>% # rolling 5-year
    #filter(year == yr & quarter == q)  %>%   # no rolling
    filter((year == yr-1 & quarter >= q) | (year == yr  & quarter <= q )) %>%  # rolling 2-year
    #filter((year == yr-1 & quarter >= q) | (year == yr) |  (year == yr + 1  & quarter <= q-1 )) %>%  # rolling 3-year
    mutate(year = yr) %>% 
    mutate(quarter = q) 
  final_base <- rbind(final_base, temp)
}  
}
base <- final_base
base <- final_base %>% mutate(year = year - 1)

after_rolling  <- base


# counting sector-sector within state movements
base <- base %>%
  select(-month, -H_ID, -P_ID, -gender) %>%
  filter(person_weight_1!= -1) %>%
  group_by(year, quarter, state_ori, sector_ori, state_dest, sector_dest) %>%
  mutate(n_cps = sum(person_weight_1/(10000))) %>%
  ungroup() %>%
  distinct(year, quarter, state_ori, sector_ori, state_dest, sector_dest, .keep_all = TRUE) %>%
  select(year, quarter, state_ori, sector_ori, state_dest, sector_dest, n_cps)


# adding missing combinations

temp <- data.frame(s_names)  
sec  <- c(0:14)
temp_sec  <- data.frame(sec)
yr  <- c(1999:2006)
temp_yr  <- data.frame(yr) 
qr  <- c(1:4)
temp_qr  <- data.frame(qr)
combo_st_sec_yr  <- expand.grid(year = temp_yr$yr, quarter = temp_qr$qr, state_ori = temp$s_names, state_dest = temp$s_names, sector_ori = temp_sec$sec, sector_dest = temp_sec$sec) 

cps  <- combo_st_sec_yr  %>% 
  left_join(base, by = c('year'='year', 'quarter'='quarter', 'state_ori'='state_ori', 'state_dest'='state_dest', 'sector_ori'='sector_ori','sector_dest'='sector_dest'))  %>% 
  mutate(n_cps = ifelse(is.na(n_cps), 0, n_cps))

cps_  <- cps

############################ Modification: proportionality assumption on diagonals ##################################
# replacing 0 in diag based on median non-zero diag shares within year-sector
temp <- cps  %>% 
  mutate(diag = ifelse(sector_ori == sector_dest & state_ori == state_dest, 1, 0))  %>% 
  group_by(year, quarter, state_ori, sector_ori)  %>% 
  mutate(stock_ori = sum(n_cps))  %>% 
  mutate(outflow_share = n_cps/stock_ori)  %>% 
  mutate(outflow_share = ifelse(is.na(outflow_share), 0, outflow_share))  %>% 
  mutate(stay_in_share = ifelse(diag == 1, outflow_share, 0))  %>% 
  mutate(stay_in_share = max(stay_in_share))  %>%   # filter out the stay_in_share for each pair
  ungroup() %>% 
  group_by(year,quarter, sector_ori)  %>% 
  mutate(stay_in_share_median = median(stay_in_share))  %>% # filter out the median of stay_in_share of the sector
  ungroup()  %>% 
  group_by(year, quarter, state_dest, sector_dest)  %>% 
  mutate(stock_dest = sum(n_cps))  %>% 
  mutate(stock_dest_diag = ifelse(diag == 1, stock_dest, 0))  %>% 
  ungroup()  %>% 
  group_by(year, quarter, state_ori, sector_ori)  %>% 
  #group_by(year, quarter, sector_ori)  %>% 
  mutate(stock_dest_diag = max(stock_dest_diag))  %>% 
  ungroup()  %>% 
  mutate(diag_new = pmax(1, stock_ori, stock_dest_diag)/(1-stay_in_share_median) * stay_in_share_median)  %>%  #If the diagonal flow is missing, then total outflow == stock at the original, total inflow == stock at the destination
  mutate(flag = ifelse(diag == 1 & n_cps == 0, 1, 0))  %>%  #7 cases in 1999: Hawaii sector 6 (2-4 quarters)  Alaska sector 6 (4 quarters)
  mutate(n_cps = ifelse(diag == 1 & n_cps == 0, diag_new, n_cps))  %>% 
  select(year, quarter, state_ori, sector_ori, state_dest, sector_dest, n_cps) 
cps  <- temp

#filling missing matrix sections as CDP
cps <- cps %>%
  mutate(n_master = ifelse(state_ori == state_dest, n_cps, 0)) %>%
  select(-n_cps) %>%   #actually, n_master == n_cps......
  group_by(year, quarter, state_dest, sector_dest, sector_ori) %>% #based on destination state
  mutate(n_cps = max(n_master)) %>%  #n_cps:  each entry takes the value of within destination state migration for that sector-sector movement, therefore same value for same (year, state_dest, sector_dest, sector_ori) across original states
  ungroup() %>%
  select(-n_master) %>%
  arrange(year, quarter, state_dest, sector_dest, state_ori, sector_ori)

write.table(cps, file = paste("1-Intermediate_Processed_Data/cps_2_quarterly.csv", sep=""), sep = ",", row.names = FALSE) 
#################################################################################################################################

############################ Old code without modification ##################################
# replacing 0 in diag for min non-zero diag value
temp <- cps_ %>%
  mutate(diag = ifelse(sector_ori == sector_dest & state_ori == state_dest, 1, 0)) %>%
  filter(diag == 1 & n_cps != 0) %>%
  group_by(year, quarter, diag) %>%
  mutate(min_diag = min(n_cps)) %>% #min non-zero diag value within the same year across all diagonals
  ungroup() %>%
  distinct(year, quarter, .keep_all = TRUE) %>%
  select(year, quarter, min_diag)  #year 1999, 2000, 2001, the minimum is 264.8371; year 2002, the minimum is 277.1613; year 2003, 2004, 2005, 2006, the minimum is 230.9756. 
cps_ <- cps_ %>%
  left_join(temp, by=c("year"="year", "quarter"="quarter")) %>%
  mutate(diag = ifelse(sector_ori == sector_dest & state_ori == state_dest, 1, 0)) %>%
  mutate(n_cps = ifelse(diag == 1 & n_cps == 0 , min_diag, n_cps)) %>% #108 cases
  select(-min_diag, -diag) # n_cps: only have within state movements sector-sector migration flows (all diag missing are filled), across state equals zero
rm(temp)

# filling missing matrix sections as CDP
cps_ <- cps_ %>%
  mutate(n_master = ifelse(state_ori == state_dest, n_cps, 0)) %>%
  select(-n_cps) %>%   #actually, n_master == n_cps......
  group_by(year, quarter, state_dest, sector_dest, sector_ori) %>% #based on destination state
  mutate(n_cps = max(n_master)) %>%  #n_cps:  each entry takes the value of within destination state migration for that sector movement, therefore same value for same (state_dest, sector_dest)
  ungroup() %>%
  select(-n_master) %>%
  arrange(year, quarter, state_dest, sector_dest, state_ori, sector_ori)
write.table(cps_, file = paste("1-Intermediate_Processed_Data/cps_2_case0_quarterly.csv", sep=""), sep = ",", row.names = FALSE) 

```
### Check CPS
```{r}
# sectoral mobility from CPS
## Quarterly
cps_test <- read.csv(paste("1-Intermediate_Processed_Data/cps_2_quarterly.csv", sep=""), header = TRUE, sep = ",", dec = ".")

temp_case1   <- cps_test  %>% 
  distinct(year, quarter, state_dest, sector_dest, sector_ori, n_cps)  %>% 
  filter(year == 1999) %>% 
  rename(state = state_dest)

temp_case1  <- temp_case1  %>% 
  group_by(year, quarter, state, sector_ori)  %>%
  mutate(sum_sec = sum(n_cps))  %>% 
  ungroup()  %>% 
  mutate(share_sec = n_cps/sum_sec)  %>% 
  mutate(flag = ifelse(sector_ori == sector_dest, 1, 0))
#View(temp_case1)
#View(temp_case1[temp_case1$flag == 1,])

temp_case1_diag = temp_case1[temp_case1$flag == 1 & temp_case1$quarter == 4,]
#View(temp_case1[temp_case1$flag == 1 & temp_case1$quarter == 4,])
#View(temp_case1[temp_case1$flag == 1 & temp_case1$quarter == 3,])

column <- temp_case1_diag$share_sec
cat("Mean:", mean(column) * 100, "\n")
cat("Maximum:", max(column) * 100, "\n")
cat("Minimum:", min(column) * 100, "\n")
cat("25th Percentile:", quantile(column, 0.25) * 100, "\n")
cat("50th Percentile:", median(column) * 100, "\n")
cat("75th Percentile:", quantile(column, 0.75) * 100, "\n")

## Yearly
cps_test <- read.csv(paste("1-Intermediate_Processed_Data/cps_2.csv", sep=""), header = TRUE, sep = ",", dec = ".")

temp_case1   <- cps_test  %>% 
  distinct(year, state_dest, sector_dest, sector_ori, n_cps)  %>% 
  filter(year == 1999) %>% 
  rename(state = state_dest) 

temp_case1  <- temp_case1  %>% 
  group_by(year, state, sector_ori)  %>%
  mutate(sum_sec = sum(n_cps))  %>% 
  ungroup()  %>% 
  mutate(share_sec = n_cps/sum_sec)  %>% 
  mutate(flag = ifelse(sector_ori == sector_dest, 1, 0))
#View(temp_case1)
#View(temp_case1[temp_case1$flag == 1,])

temp_case1_diag = temp_case1[temp_case1$flag == 1,]

column <- temp_case1_diag$share_sec
cat("Mean:", mean(column) * 100, "\n")
cat("Maximum:", max(column) * 100, "\n")
cat("Minimum:", min(column) * 100, "\n")
cat("25th Percentile:", quantile(column, 0.25) * 100, "\n")
cat("50th Percentile:", median(column) * 100, "\n")
cat("75th Percentile:", quantile(column, 0.75) * 100, "\n")


# Quarterly
cps_test <- read.csv(paste("1-Intermediate_Processed_Data/cps_2_quarterly.csv", sep=""), header = TRUE, sep = ",", dec = ".")


# within state changing sector share
cps_same_state_chg_sec  <- cps_test  %>%
  distinct(year, quarter, state_dest, sector_ori, sector_dest, n_cps)  %>% 
  group_by(year, quarter, state_dest, sector_ori)  %>% 
  mutate(n_cps_ori = sum(n_cps))  %>% 
  mutate(ouflow_share = n_cps/n_cps_ori)  %>% 
  ungroup()  %>% 
  group_by(year, quarter, sector_ori, sector_dest)  %>% 
  mutate(outflow_share_ave = mean(ouflow_share))  %>% 
  ungroup()  %>% 
  mutate(flag = ifelse(sector_ori == sector_dest, 1, 0))

# average across all states for each origin-destination sector pairs 
chg_sec_average  <- cps_same_state_chg_sec  %>% 
  distinct(year, quarter, sector_ori, sector_dest, outflow_share_ave)  %>% 
  mutate(flag = ifelse(sector_ori == sector_dest, 1, 0) )



```





















